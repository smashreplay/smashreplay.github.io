<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Basketball Highlights Detector</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 32px;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 16px;
        }

        .content {
            padding: 30px;
        }

        .input-section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 12px;
            margin-bottom: 30px;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .tab {
            padding: 10px 20px;
            border: none;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .tab:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .tab.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        input[type="text"],
        input[type="file"] {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid #e1e8ed;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.2s;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .btn-primary:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: #e1e8ed;
            color: #333;
        }

        .btn-secondary:hover {
            background: #d1d8dd;
        }

        .video-section {
            display: grid;
            grid-template-columns: 1.5fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
            align-items: start;
        }

        @media (max-width: 968px) {
            .video-section {
                grid-template-columns: 1fr;
            }
        }

        /* Mobile-specific styles for phones */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .container {
                border-radius: 8px;
            }
            
            .header {
                padding: 15px 20px !important;
            }
            
            .header h1 {
                font-size: 20px !important;
            }
            
            .content {
                padding: 15px !important;
            }
            
            .upload-section {
                padding: 20px !important;
            }
            
            .tabs {
                flex-direction: column;
                gap: 8px;
            }
            
            .tab {
                width: 100%;
                justify-content: center;
            }
            
            .btn {
                padding: 12px 20px !important;
                font-size: 14px !important;
                width: 100%;
            }
            
            .video-section {
                padding: 15px !important;
            }
            
            .settings {
                padding: 15px !important;
            }
            
            /* Make sure video player is visible */
            .video-container {
                height: auto !important;
                min-height: 200px;
            }
            
            .video-container video {
                width: 100%;
                height: auto;
            }
            
            /* Stack highlights vertically on mobile */
            .highlights-container {
                max-height: 400px;
            }
            
            .highlight-item {
                flex-direction: row;
                padding: 10px;
            }
            
            .highlight-thumbnail {
                width: 100px !important;
                height: 75px !important;
            }
            
            /* Make overlay more compact on mobile */
            #videoOverlay {
                padding: 8px 12px !important;
                font-size: 12px !important;
                bottom: 50px !important;
            }
            
            #videoOverlay button {
                width: 28px !important;
                height: 28px !important;
                font-size: 14px !important;
            }
            
            /* Guided setup on mobile */
            #setupGuide {
                padding: 15px !important;
                font-size: 14px;
            }
            
            #setupGuide .btn {
                font-size: 13px !important;
                padding: 10px 15px !important;
            }
        }

        @media (max-width: 480px) {
            body {
                padding: 5px;
            }
            
            .header h1 {
                font-size: 18px !important;
            }
            
            .content {
                padding: 10px !important;
            }
            
            .upload-section {
                padding: 15px !important;
            }
            
            /* Even more compact on very small screens */
            #videoOverlay {
                font-size: 11px !important;
                padding: 6px 10px !important;
            }
        }

        .video-column {
            position: sticky;
            top: 20px;
        }

        .video-section.theater-mode {
            grid-template-columns: 1fr;
            gap: 15px;
        }

        .video-section.theater-mode .video-column {
            position: relative;
        }

        .video-section.theater-mode .video-container {
            height: 70vh;
        }

        .video-section.theater-mode video {
            height: 100%;
            object-fit: contain;
        }

        .video-section.theater-mode #videoOverlay {
            bottom: 80px;
            font-size: 16px;
        }

        .video-section.theater-mode .highlights-container {
            max-height: none;
        }

        .video-section.theater-mode .highlights-list {
            display: flex;
            flex-direction: row;
            overflow-x: auto;
            overflow-y: hidden;
            gap: 12px;
            padding-bottom: 10px;
            scroll-behavior: smooth;
        }

        .video-section.theater-mode .highlight-item {
            flex-direction: column;
            min-width: 160px;
            max-width: 160px;
        }

        .video-section.theater-mode .highlight-thumbnail {
            width: 100%;
            height: 90px;
        }

        .highlight-item.playing {
            border-color: #667eea;
            background: #f0f4ff;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.3);
        }

        .video-container {
            background: #000;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }

        video {
            width: 100%;
            display: block;
        }

        canvas {
            display: none;
        }

        #selectionCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: default;
            display: none;
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
        }

        #selectionCanvas.active {
            display: block;
        }

        #selectionCanvas.has-regions {
            display: block;
            pointer-events: none;
        }

        .basket-overlay-controls {
            display: none;
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 200;
            gap: 10px;
            align-items: center;
        }

        .basket-overlay-controls.active {
            display: flex;
        }

        .basket-overlay-controls button {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .basket-overlay-controls .confirm-btn {
            background: #4CAF50;
            color: white;
        }

        .basket-overlay-controls .cancel-btn {
            background: rgba(255,255,255,0.9);
            color: #333;
        }

        .region-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .region-indicator {
            background: white;
            padding: 10px 12px;
            border-radius: 8px;
            font-size: 13px;
            color: #333;
            border: 2px solid #e1e8ed;
            flex: 1;
            min-width: 180px;
        }

        .region-indicator.set {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .region-indicator strong {
            color: #667eea;
            display: block;
            margin-bottom: 4px;
        }

        .region-badge {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            margin-left: 6px;
        }

        .help-text {
            font-size: 12px;
            color: #666;
            margin-top: 8px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 6px;
            border-left: 3px solid #667eea;
        }

        .highlights-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-height: calc(100vh - 100px);
            overflow-y: auto;
        }

        .highlights-list {
            display: grid;
            gap: 12px;
            max-height: none;
        }

        .progress-container {
            background: white;
            padding: 20px;
            border-radius: 12px;
            border: 2px solid #e1e8ed;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e1e8ed;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s;
        }

        .progress-text {
            text-align: center;
            color: #666;
            font-size: 14px;
        }

        .motion-chart-container {
            margin-top: 15px;
            background: #1a1a2e;
            border-radius: 8px;
            padding: 12px;
            position: relative;
        }

        .motion-chart-container h4 {
            color: #ccc;
            font-size: 12px;
            margin: 0 0 8px 0;
            font-weight: 600;
        }

        .motion-chart-legend {
            display: flex;
            gap: 12px;
            font-size: 10px;
            color: #aaa;
            margin-top: 6px;
            flex-wrap: wrap;
        }

        .motion-chart-legend span {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .motion-chart-legend .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
        }

        .status {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status.processing {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .status.complete {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .highlights-section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 12px;
        }

        .highlights-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .highlights-header h2 {
            font-size: 24px;
            color: #333;
        }

        .highlight-count {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
        }

        .highlights-list {
            display: grid;
            gap: 12px;
        }

        .highlight-item {
            background: white;
            padding: 12px;
            border-radius: 8px;
            display: flex;
            gap: 12px;
            align-items: center;
            transition: all 0.2s;
            cursor: pointer;
            border: 2px solid transparent;
        }

        .highlight-item:hover {
            border-color: #667eea;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
        }

        .highlight-thumbnail {
            width: 140px;
            height: 105px;
            background: #000;
            border-radius: 6px;
            overflow: hidden;
            flex-shrink: 0;
            position: relative;
        }

        .highlight-thumbnail img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .highlight-thumbnail .play-icon {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 24px;
            height: 24px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        .highlight-info {
            display: flex;
            flex-direction: column;
            gap: 4px;
            flex: 1;
        }

        .highlight-number {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
            flex-shrink: 0;
        }

        .highlight-time {
            font-size: 16px;
            font-weight: 600;
            color: #333;
        }

        .confidence {
            font-size: 11px;
            color: #666;
            background: #e1e8ed;
            padding: 3px 6px;
            border-radius: 4px;
            display: inline-block;
        }

        .region-label {
            font-size: 11px;
            color: #667eea;
            font-weight: 600;
        }

        .export-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px solid #e1e8ed;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #999;
        }

        .empty-state svg {
            width: 80px;
            height: 80px;
            margin-bottom: 20px;
            opacity: 0.3;
        }

        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 0.6s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .settings {
            background: white;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
        }

        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .setting-row:last-child {
            margin-bottom: 0;
        }

        .setting-label {
            font-size: 14px;
            color: #333;
            font-weight: 500;
        }

        .setting-description {
            font-size: 12px;
            color: #666;
            margin-top: 4px;
        }

        input[type="range"] {
            width: 150px;
        }

        .setting-value {
            font-size: 14px;
            font-weight: 600;
            color: #667eea;
            min-width: 40px;
            text-align: right;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üèÄ Basketball Highlights Detector</h1>
            <p>Automatically find made baskets in your pickup game videos</p>
        </div>

        <div class="content">
            <!-- Input Section -->
            <div class="input-section">
                <div class="tabs">
                    <button class="tab active" id="fileTab" onclick="switchTab('file')">Load Video</button>
                    <button class="tab" id="urlTab" onclick="switchTab('url')">Use URL</button>
                </div>

                <div id="fileInput">
                    <div class="input-group" style="flex-direction: column;">
                        <input type="file" id="videoFile" accept="video/*" onchange="handleFileUpload(event)">
                    </div>
                </div>

                <div id="urlInput" style="display: none;">
                    <div class="input-group">
                        <input type="text" id="videoUrl" placeholder="Enter video URL (e.g., https://example.com/video.mp4 or Google Drive link)" onkeypress="if(event.key==='Enter') loadVideo()">
                    </div>
                    <p style="font-size: 12px; color: #666; margin-top: 8px;">
                        üí° For Google Drive: Share the video ‚Üí Get link ‚Üí Change to "Anyone with the link" ‚Üí Use direct link
                    </p>
                </div>
            </div>

            <!-- Settings -->
            <div class="settings" id="settingsPanel" style="display: none;">
                <h3 style="margin-bottom: 15px; color: #333;">Detection Settings</h3>
                
                <div class="setting-row">
                    <div>
                        <div class="setting-label">Min. Gap Between Clips</div>
                        <div class="setting-description">Minimum seconds between detected baskets</div>
                    </div>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <input type="range" id="minGap" min="2" max="10" value="3" oninput="updateSettings()">
                        <span class="setting-value" id="minGapValue">3s</span>
                    </div>
                </div>
            </div>

            <!-- Video Section -->
            <div class="video-section" id="videoSection" style="display: none;">
                <div class="video-column">
                    <!-- Guided Setup Steps -->
                    <div id="setupGuide" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 12px; margin-bottom: 20px;">
                        <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 15px;">
                            <div style="width: 40px; height: 40px; background: white; color: #667eea; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 20px;">
                                <span id="stepNumber">1</span>
                            </div>
                            <div style="flex: 1;">
                                <div style="font-size: 18px; font-weight: 600; margin-bottom: 5px;" id="stepTitle">
                                    Select First Basket Region
                                </div>
                                <div style="font-size: 14px; opacity: 0.9;" id="stepDescription">
                                    Click "Add Basket Region" below and draw a box around the basket/rim
                                </div>
                            </div>
                        </div>
                        <div style="display: flex; gap: 10px;">
                            <button class="btn" onclick="skipToProcessing()" style="background: rgba(255,255,255,0.2); color: white; border: 1px solid rgba(255,255,255,0.3);">
                                Skip to Processing
                            </button>
                        </div>
                    </div>
                    
                    <div class="video-container">
                        <video id="videoPlayer" controls></video>
                        <video id="processingVideo" style="display: none;"></video>
                        <canvas id="canvas"></canvas>
                        <canvas id="selectionCanvas"></canvas>
                        <div class="basket-overlay-controls" id="basketOverlayControls">
                            <button class="cancel-btn" onclick="cancelOverlaySelection()">Cancel</button>
                            <button class="confirm-btn" onclick="confirmOverlaySelection()">Confirm</button>
                        </div>

                        <!-- Simplified Video Overlay - positioned below video controls -->
                        <div id="videoOverlay" style="display: none; position: absolute; bottom: 60px; left: 10px; right: 10px; background: rgba(0, 0, 0, 0.8); padding: 12px 16px; border-radius: 8px; color: white; font-family: sans-serif; z-index: 100; pointer-events: auto;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div style="display: flex; align-items: center; gap: 15px;">
                                    <button onclick="playPreviousClip()" style="background: rgba(255,255,255,0.2); border: none; color: white; width: 32px; height: 32px; border-radius: 50%; cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center; pointer-events: auto;">
                                        ‚óÄ
                                    </button>
                                    <div>
                                        <div style="font-size: 14px; font-weight: 600;">
                                            Clip <span id="overlayClipNumber">1</span> of <span id="overlayTotalClips">0</span>
                                        </div>
                                        <div style="font-size: 11px; color: #ddd; margin-top: 2px;">
                                            <span id="overlayTimestamp">0:00</span> ‚Ä¢ <span id="overlayClipTime">0.0s</span>/<span id="overlayClipDuration">4.0s</span>
                                        </div>
                                    </div>
                                    <button onclick="playNextClip()" style="background: rgba(255,255,255,0.2); border: none; color: white; width: 32px; height: 32px; border-radius: 50%; cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center; pointer-events: auto;">
                                        ‚ñ∂
                                    </button>
                                </div>
                                <div style="flex: 1; margin: 0 15px;">
                                    <div style="width: 100%; height: 4px; background: rgba(255, 255, 255, 0.3); border-radius: 2px; overflow: hidden;">
                                        <div id="overlayProgress" style="width: 0%; height: 100%; background: linear-gradient(90deg, #667eea 0%, #764ba2 100%); transition: width 0.1s linear;"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="region-controls">
                        <div class="region-indicator" id="regionIndicator">
                            <strong>üéØ Basket Regions:</strong>
                            <div id="regionList">None selected</div>
                        </div>
                    </div>
                    <div style="display: flex; gap: 10px; margin-top: 10px;">
                        <button class="btn btn-primary" onclick="startRegionSelection()" id="selectRegionBtn" style="flex: 1;">
                            üìç Add Basket Region
                        </button>
                        <button class="btn btn-secondary" onclick="clearLastRegion()" id="clearRegionBtn" style="display: none;">
                            ‚úï Remove
                        </button>
                    </div>
                    <div class="help-text" id="regionHelp" style="display: none; background: #f0f4ff; padding: 12px; border-radius: 8px; margin-top: 10px; font-size: 13px; color: #333;">
                        <strong>Drag the box</strong> over the basket, then <strong>drag corners</strong> to resize. Tap <strong>Confirm</strong> when done.
                    </div>
                    
                    <button class="btn btn-primary" onclick="processVideo()" id="processBtn" style="margin-top: 15px; width: 100%; display: none;">
                        <span>‚ñ∂ Play Clips</span>
                    </button>
                    
                    <button class="btn btn-primary" onclick="playAllHighlights()" id="playAllBtn" style="margin-top: 10px; width: 100%; display: none; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                        <span>‚ñ∂ Play All Highlights</span>
                    </button>
                </div>

                <div class="highlights-container">
                    <div class="progress-container" id="progressContainer" style="display: none;">
                        <h3 style="margin-bottom: 15px;">Processing...</h3>
                        <div class="progress-bar">
                            <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                        </div>
                        <div class="progress-text" id="progressText">0%</div>
                        <div style="font-size: 13px; color: #333; margin-top: 15px; padding: 12px; background: white; border-radius: 8px;">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                <span>üé¨ Frames Analyzed:</span>
                                <strong id="framesAnalyzed">0</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                <span>üèÄ Baskets Found:</span>
                                <strong id="basketsFound">0</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between;">
                                <span>‚è±Ô∏è Current Time:</span>
                                <strong id="currentProcessTime">0:00</strong>
                            </div>
                        </div>
                        <p style="font-size: 12px; color: #666; margin-top: 10px; text-align: center;">
                            üí° You can watch the main video while processing continues
                        </p>
                        <div class="motion-chart-container">
                            <h4>Motion Analysis</h4>
                            <canvas id="motionChart" width="600" height="150" style="width: 100%; height: 150px;"></canvas>
                            <div class="motion-chart-legend">
                                <span><span class="dot" style="background: #4fc3f7;"></span> Motion</span>
                                <span><span class="dot" style="background: #ff8a65;"></span> Rim Color</span>
                                <span><span class="dot" style="background: #ffd54f;"></span> Ball Color</span>
                                <span><span class="dot" style="background: #4CAF50;"></span> Detection</span>
                                <span style="color: #666;">Threshold: <span id="motionThresholdLabel">--</span></span>
                            </div>
                        </div>
                    </div>

                    <!-- Motion chart shown after processing -->
                    <div class="motion-chart-container" id="motionChartFinal" style="display: none;">
                        <h4>Motion Analysis (complete)</h4>
                        <canvas id="motionChartComplete" width="600" height="180" style="width: 100%; height: 180px;"></canvas>
                        <div class="motion-chart-legend">
                            <span><span class="dot" style="background: #4fc3f7;"></span> Motion</span>
                            <span><span class="dot" style="background: #ff8a65;"></span> Rim Color</span>
                            <span><span class="dot" style="background: #ffd54f;"></span> Ball Color</span>
                            <span><span class="dot" style="background: #4CAF50;"></span> Detection</span>
                        </div>
                    </div>

                    <!-- Highlights Section -->
                    <div class="highlights-section" id="highlightsSection" style="display: none;">
                        <div class="highlights-header">
                            <h2>Detected Highlights</h2>
                            <span class="highlight-count" id="highlightCount">0 baskets</span>
                        </div>
                        
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 6px; margin-bottom: 12px; font-size: 11px; color: #666;">
                            <strong>Debug Info:</strong> M=Motion, R=Rim, B=Ball 
                            | üìâ=Motion Drop, üéØ=Rim Found, üèÄ=Ball Detected
                        </div>

                        <div class="highlights-list" id="highlightsList"></div>

                        <div class="export-section">
                            <button class="btn btn-secondary" onclick="exportTimestamps()">
                                üìã Copy Timestamps
                            </button>
                            <button class="btn btn-secondary" onclick="exportJSON()" style="margin-left: 10px;">
                                üíæ Download JSON
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Status Messages -->
            <div id="statusMessage" style="display: none;"></div>

            <!-- Empty State -->
            <div class="empty-state" id="emptyState">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"></circle>
                    <polygon points="10 8 16 12 10 16 10 8"></polygon>
                </svg>
                <h3>No video loaded</h3>
                <p>Upload a video file or paste a URL to get started</p>
            </div>
        </div>
    </div>

    <script>
        let currentTab = 'file';
        let videoFile = null;
        let highlights = [];
        let settings = {
            minGap: 3  // Minimum gap between clips in seconds
        };
        
        // Region selection variables - now supports multiple regions
        let basketRegions = [];
        let isSelectingRegion = false;
        let selectionCanvas = null;
        let selectionCtx = null;
        const MAX_REGIONS = 2;
        
        // Playback mode variables
        let isPlayingAll = false;
        let currentHighlightIndex = 0;
        let isTheaterMode = false;
        let playAllListener = null;

        // Motion chart data
        let chartData = [];        // {time, motion, rim, ball, detected}
        let chartDetections = [];  // timestamps where detections fired

        function switchTab(tab) {
            currentTab = tab;
            document.getElementById('fileTab').classList.toggle('active', tab === 'file');
            document.getElementById('urlTab').classList.toggle('active', tab === 'url');
            document.getElementById('fileInput').style.display = tab === 'file' ? 'block' : 'none';
            document.getElementById('urlInput').style.display = tab === 'url' ? 'block' : 'none';
        }

        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (file) {
                videoFile = file;
                loadVideo();
            }
        }

        function loadVideo() {
            const video = document.getElementById('videoPlayer');
            const processingVideo = document.getElementById('processingVideo');
            
            if (currentTab === 'file' && videoFile) {
                const url = URL.createObjectURL(videoFile);
                video.src = url;
                processingVideo.src = url;
            } else if (currentTab === 'url') {
                let url = document.getElementById('videoUrl').value.trim();
                
                // Handle Google Drive links
                if (url.includes('drive.google.com')) {
                    const fileId = extractGoogleDriveId(url);
                    if (fileId) {
                        url = `https://drive.google.com/uc?export=download&id=${fileId}`;
                    }
                }
                
                video.src = url;
                processingVideo.src = url;
            }

            video.onloadedmetadata = () => {
                document.getElementById('emptyState').style.display = 'none';
                document.getElementById('videoSection').style.display = 'grid';
                document.getElementById('settingsPanel').style.display = 'block';
                highlights = [];
                basketRegions = [];
                updateHighlightsDisplay();
                updateRegionDisplay();
                
                // Initialize selection canvas
                initSelectionCanvas();
                
                // Set up keyboard navigation
                setupKeyboardNavigation();
            };

            video.onerror = () => {
                showStatus('Error loading video. Check the URL or file format.', 'error');
            };
        }

        function extractGoogleDriveId(url) {
            const patterns = [
                /\/d\/([a-zA-Z0-9-_]+)/,
                /id=([a-zA-Z0-9-_]+)/,
                /\/file\/d\/([a-zA-Z0-9-_]+)/
            ];
            
            for (const pattern of patterns) {
                const match = url.match(pattern);
                if (match) return match[1];
            }
            return null;
        }

        function updateSettings() {
            settings.minGap = parseInt(document.getElementById('minGap').value);
            document.getElementById('minGapValue').textContent = settings.minGap + 's';
        }

        function initSelectionCanvas() {
            const video = document.getElementById('videoPlayer');
            selectionCanvas = document.getElementById('selectionCanvas');
            selectionCtx = selectionCanvas.getContext('2d');

            // Match canvas size to video element
            const updateCanvasSize = () => {
                const rect = video.getBoundingClientRect();
                selectionCanvas.width = rect.width;
                selectionCanvas.height = rect.height;
                redrawRegion();
            };

            updateCanvasSize();
            window.addEventListener('resize', updateCanvasSize);

            // Interaction handlers for draggable overlay
            selectionCanvas.addEventListener('mousedown', handleOverlayPointerDown);
            selectionCanvas.addEventListener('mousemove', handleOverlayPointerMove);
            selectionCanvas.addEventListener('mouseup', handleOverlayPointerUp);
            selectionCanvas.addEventListener('touchstart', handleOverlayPointerDown, { passive: false });
            selectionCanvas.addEventListener('touchmove', handleOverlayPointerMove, { passive: false });
            selectionCanvas.addEventListener('touchend', handleOverlayPointerUp, { passive: false });
        }

        // Draggable/resizable overlay state
        let overlayRegion = null;      // The region being edited {x, y, width, height} in normalized coords
        let overlayDragType = null;    // 'move', 'tl', 'tr', 'bl', 'br' (corners)
        let overlayDragStart = null;   // {x, y} in normalized coords where drag started
        let overlayOriginal = null;    // Copy of region at drag start
        const HANDLE_SIZE = 22;        // px ‚Äî touch-friendly handle radius
        const MIN_REGION_SIZE = 0.08;  // Minimum 8% of video in either dimension

        function getPointerPos(e) {
            const rect = selectionCanvas.getBoundingClientRect();
            const touch = e.touches ? e.touches[0] : (e.changedTouches ? e.changedTouches[0] : e);
            return {
                px: (touch.clientX || e.clientX) - rect.left,
                py: (touch.clientY || e.clientY) - rect.top,
                nx: ((touch.clientX || e.clientX) - rect.left) / selectionCanvas.width,
                ny: ((touch.clientY || e.clientY) - rect.top) / selectionCanvas.height
            };
        }

        function hitTestOverlay(px, py) {
            if (!overlayRegion) return null;
            const r = overlayRegion;
            const x = r.x * selectionCanvas.width;
            const y = r.y * selectionCanvas.height;
            const w = r.width * selectionCanvas.width;
            const h = r.height * selectionCanvas.height;
            const hs = HANDLE_SIZE;

            // Test corners first (larger hit area for touch)
            if (Math.abs(px - x) < hs && Math.abs(py - y) < hs) return 'tl';
            if (Math.abs(px - (x + w)) < hs && Math.abs(py - y) < hs) return 'tr';
            if (Math.abs(px - x) < hs && Math.abs(py - (y + h)) < hs) return 'bl';
            if (Math.abs(px - (x + w)) < hs && Math.abs(py - (y + h)) < hs) return 'br';

            // Test inside box for move
            if (px >= x && px <= x + w && py >= y && py <= y + h) return 'move';

            return null;
        }

        function handleOverlayPointerDown(e) {
            if (!isSelectingRegion || !overlayRegion) return;
            e.preventDefault();
            const pos = getPointerPos(e);
            const hit = hitTestOverlay(pos.px, pos.py);
            if (!hit) return;

            overlayDragType = hit;
            overlayDragStart = { nx: pos.nx, ny: pos.ny };
            overlayOriginal = { ...overlayRegion };
        }

        function handleOverlayPointerMove(e) {
            if (!isSelectingRegion || !overlayRegion) return;
            e.preventDefault();
            const pos = getPointerPos(e);

            if (!overlayDragType) {
                // Update cursor based on hover
                const hit = hitTestOverlay(pos.px, pos.py);
                if (hit === 'move') selectionCanvas.style.cursor = 'grab';
                else if (hit) selectionCanvas.style.cursor = 'nwse-resize';
                else selectionCanvas.style.cursor = 'default';
                return;
            }

            // Active drag
            selectionCanvas.style.cursor = overlayDragType === 'move' ? 'grabbing' : 'nwse-resize';
            const dx = pos.nx - overlayDragStart.nx;
            const dy = pos.ny - overlayDragStart.ny;
            const o = overlayOriginal;

            if (overlayDragType === 'move') {
                overlayRegion.x = Math.max(0, Math.min(1 - o.width, o.x + dx));
                overlayRegion.y = Math.max(0, Math.min(1 - o.height, o.y + dy));
            } else {
                // Corner resize
                let newX = o.x, newY = o.y, newW = o.width, newH = o.height;

                if (overlayDragType === 'tl') {
                    newX = o.x + dx;
                    newY = o.y + dy;
                    newW = o.width - dx;
                    newH = o.height - dy;
                } else if (overlayDragType === 'tr') {
                    newY = o.y + dy;
                    newW = o.width + dx;
                    newH = o.height - dy;
                } else if (overlayDragType === 'bl') {
                    newX = o.x + dx;
                    newW = o.width - dx;
                    newH = o.height + dy;
                } else if (overlayDragType === 'br') {
                    newW = o.width + dx;
                    newH = o.height + dy;
                }

                // Enforce minimum size
                if (newW >= MIN_REGION_SIZE && newH >= MIN_REGION_SIZE) {
                    overlayRegion.x = Math.max(0, Math.min(1 - MIN_REGION_SIZE, newX));
                    overlayRegion.y = Math.max(0, Math.min(1 - MIN_REGION_SIZE, newY));
                    overlayRegion.width = Math.min(newW, 1 - overlayRegion.x);
                    overlayRegion.height = Math.min(newH, 1 - overlayRegion.y);
                }
            }

            drawOverlay();
        }

        function handleOverlayPointerUp(e) {
            if (!isSelectingRegion) return;
            e.preventDefault();
            overlayDragType = null;
            overlayDragStart = null;
            overlayOriginal = null;
            if (overlayRegion) {
                const hit = hitTestOverlay(getPointerPos(e).px, getPointerPos(e).py);
                selectionCanvas.style.cursor = hit === 'move' ? 'grab' : (hit ? 'nwse-resize' : 'default');
            }
        }

        function drawOverlay() {
            if (!selectionCanvas) return;
            selectionCtx.clearRect(0, 0, selectionCanvas.width, selectionCanvas.height);

            // Dark overlay
            selectionCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            selectionCtx.fillRect(0, 0, selectionCanvas.width, selectionCanvas.height);

            if (!overlayRegion) return;

            const r = overlayRegion;
            const x = r.x * selectionCanvas.width;
            const y = r.y * selectionCanvas.height;
            const w = r.width * selectionCanvas.width;
            const h = r.height * selectionCanvas.height;

            const colors = ['#667eea', '#f5576c'];
            const color = colors[basketRegions.length % colors.length];

            // Clear the region area (make it bright/visible)
            selectionCtx.clearRect(x, y, w, h);

            // Draw border
            selectionCtx.strokeStyle = color;
            selectionCtx.lineWidth = 3;
            selectionCtx.strokeRect(x, y, w, h);

            // Draw corner handles
            const hs = 12; // visual handle half-size
            const corners = [
                [x, y], [x + w, y],
                [x, y + h], [x + w, y + h]
            ];
            corners.forEach(([cx, cy]) => {
                selectionCtx.fillStyle = 'white';
                selectionCtx.beginPath();
                selectionCtx.arc(cx, cy, hs, 0, Math.PI * 2);
                selectionCtx.fill();
                selectionCtx.strokeStyle = color;
                selectionCtx.lineWidth = 3;
                selectionCtx.stroke();
            });

            // Draw label
            const label = `BASKET ${basketRegions.length + 1}`;
            selectionCtx.font = 'bold 12px sans-serif';
            const textWidth = selectionCtx.measureText(label).width;
            selectionCtx.fillStyle = color;
            selectionCtx.fillRect(x, y - 24, textWidth + 10, 22);
            selectionCtx.fillStyle = 'white';
            selectionCtx.fillText(label, x + 5, y - 9);
        }

        function toggleRegionSelection() {
            if (basketRegions.length >= MAX_REGIONS && !isSelectingRegion) {
                return;
            }

            isSelectingRegion = !isSelectingRegion;

            const canvas = document.getElementById('selectionCanvas');
            const btn = document.getElementById('selectRegionBtn');
            const help = document.getElementById('regionHelp');
            const overlayControls = document.getElementById('basketOverlayControls');

            if (isSelectingRegion) {
                canvas.classList.add('active');
                canvas.classList.remove('has-regions');
                btn.textContent = '‚úï Cancel Selection';
                btn.classList.remove('btn-secondary');
                btn.classList.add('btn-primary');
                help.style.display = 'block';
                overlayControls.classList.add('active');
                document.getElementById('videoPlayer').pause();

                // Create a default overlay region centered on the video
                overlayRegion = { x: 0.35, y: 0.25, width: 0.30, height: 0.35 };
                drawOverlay();
            } else {
                canvas.classList.remove('active');
                if (basketRegions.length > 0) canvas.classList.add('has-regions');
                btn.textContent = 'üìç Add Basket Region';
                btn.classList.remove('btn-primary');
                btn.classList.add('btn-secondary');
                help.style.display = 'none';
                overlayControls.classList.remove('active');
                overlayRegion = null;
                redrawRegion();
            }
        }

        function confirmOverlaySelection() {
            if (!overlayRegion) return;

            const regionNumber = basketRegions.length + 1;
            const colors = ['#667eea', '#f5576c'];

            const newRegion = {
                x: overlayRegion.x,
                y: overlayRegion.y,
                width: overlayRegion.width,
                height: overlayRegion.height,
                number: regionNumber,
                color: colors[(regionNumber - 1) % colors.length]
            };

            basketRegions.push(newRegion);
            updateRegionDisplay();
            toggleRegionSelection();
        }

        function cancelOverlaySelection() {
            if (isSelectingRegion) {
                toggleRegionSelection();
            }
        }

        function clearLastRegion() {
            if (basketRegions.length > 0) {
                basketRegions.pop();
                updateRegionDisplay();
                showStatus('Last basket region removed.', 'complete');
            }
        }

        function clearAllRegions() {
            basketRegions = [];
            updateRegionDisplay();
            showStatus('All basket regions cleared. Will use full frame detection.', 'complete');
        }

        function updateRegionDisplay() {
            const indicator = document.getElementById('regionIndicator');
            const regionList = document.getElementById('regionList');
            const selectBtn = document.getElementById('selectRegionBtn');

            if (basketRegions.length === 0) {
                regionList.innerHTML = 'None selected';
                indicator.classList.remove('set');
                document.getElementById('clearRegionBtn').style.display = 'none';
                selectBtn.disabled = false;
                selectBtn.textContent = 'üìç Add Basket Region';
            } else {
                const badges = basketRegions.map((r, i) =>
                    `<span class="region-badge" style="background: ${r.color}">Region ${r.number}</span>`
                ).join(' ');
                regionList.innerHTML = badges;
                indicator.classList.add('set');
                document.getElementById('clearRegionBtn').style.display = 'inline-flex';
                selectBtn.disabled = basketRegions.length >= MAX_REGIONS;
                if (basketRegions.length >= MAX_REGIONS) {
                    selectBtn.textContent = 'Max regions reached';
                } else {
                    selectBtn.textContent = 'üìç Add Basket Region';
                }
            }
            
            redrawRegion();
            updateGuidedWorkflow();
        }

        function updateGuidedWorkflow() {
            const stepNumber = document.getElementById('stepNumber');
            const stepTitle = document.getElementById('stepTitle');
            const stepDescription = document.getElementById('stepDescription');
            const processBtn = document.getElementById('processBtn');
            const setupGuide = document.getElementById('setupGuide');
            
            if (basketRegions.length === 0) {
                // Step 1: No regions
                stepNumber.textContent = '1';
                stepTitle.textContent = 'Select First Basket Region';
                stepDescription.textContent = 'Tap "Add Basket Region" below, then drag and resize the box over the basket';
                processBtn.style.display = 'none';
                setupGuide.style.display = 'block';
            } else if (basketRegions.length === 1) {
                // Step 2: One region, prompt for second
                stepNumber.textContent = '2';
                stepTitle.textContent = 'Add Second Basket? (Optional)';
                stepDescription.textContent = 'If there\'s another basket visible in the video, add it now. Otherwise, click "Start Detection"';
                processBtn.style.display = 'block';
                processBtn.innerHTML = '<span>‚úì Start Detection</span>';
                setupGuide.style.display = 'block';
            } else {
                // Step 3: Ready to process
                stepNumber.textContent = '‚úì';
                stepTitle.textContent = 'Ready to Detect!';
                stepDescription.textContent = 'Both basket regions selected. Click "Start Detection" to find all the baskets!';
                processBtn.style.display = 'block';
                processBtn.innerHTML = '<span>‚úì Start Detection</span>';
                setupGuide.style.display = 'block';
            }
        }

        function startRegionSelection() {
            if (basketRegions.length >= MAX_REGIONS) {
                showStatus(`Maximum ${MAX_REGIONS} basket regions allowed.`, 'complete');
                return;
            }
            toggleRegionSelection();
        }

        function skipToProcessing() {
            document.getElementById('setupGuide').style.display = 'none';
            document.getElementById('processBtn').style.display = 'block';
            document.getElementById('processBtn').innerHTML = '<span>‚ñ∂ Start Detection</span>';
            showStatus('You can still add basket regions before processing for better accuracy.', 'complete');
        }

        function redrawRegion() {
            if (!selectionCanvas) return;

            selectionCtx.clearRect(0, 0, selectionCanvas.width, selectionCanvas.height);

            // Manage has-regions class for passive display
            if (basketRegions.length > 0 && !isSelectingRegion) {
                selectionCanvas.classList.add('has-regions');

                // Draw semi-transparent overlay
                selectionCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                selectionCtx.fillRect(0, 0, selectionCanvas.width, selectionCanvas.height);

                // Draw each saved region
                basketRegions.forEach(region => {
                    const x = region.x * selectionCanvas.width;
                    const y = region.y * selectionCanvas.height;
                    const width = region.width * selectionCanvas.width;
                    const height = region.height * selectionCanvas.height;

                    // Clear the region
                    selectionCtx.clearRect(x, y, width, height);

                    // Draw colored border
                    selectionCtx.strokeStyle = region.color;
                    selectionCtx.lineWidth = 3;
                    selectionCtx.strokeRect(x, y, width, height);

                    // Draw label with background
                    const label = `BASKET ${region.number}`;
                    selectionCtx.font = 'bold 12px sans-serif';
                    const textWidth = selectionCtx.measureText(label).width;

                    selectionCtx.fillStyle = region.color;
                    selectionCtx.fillRect(x, y, textWidth + 10, 22);

                    selectionCtx.fillStyle = 'white';
                    selectionCtx.fillText(label, x + 5, y + 15);
                });
            } else if (!isSelectingRegion) {
                selectionCanvas.classList.remove('has-regions');
            }
        }

        function drawMotionChart(canvasId, data, detections, duration) {
            const canvas = document.getElementById(canvasId);
            if (!canvas || data.length === 0) return;
            const ctx = canvas.getContext('2d');
            const W = canvas.width;
            const H = canvas.height;
            const pad = { top: 10, bottom: 20, left: 35, right: 10 };
            const plotW = W - pad.left - pad.right;
            const plotH = H - pad.top - pad.bottom;

            ctx.clearRect(0, 0, W, H);

            // Find max values for scaling
            const maxMotion = Math.max(10, ...data.map(d => d.motion));
            const maxRim = Math.max(1, ...data.map(d => d.rim));
            const maxBall = Math.max(1, ...data.map(d => d.ball));

            // Draw grid lines
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = pad.top + (plotH / 4) * i;
                ctx.beginPath();
                ctx.moveTo(pad.left, y);
                ctx.lineTo(W - pad.right, y);
                ctx.stroke();
            }

            // Y-axis labels
            ctx.fillStyle = '#888';
            ctx.font = '9px sans-serif';
            ctx.textAlign = 'right';
            for (let i = 0; i <= 4; i++) {
                const y = pad.top + (plotH / 4) * i;
                const val = Math.round(maxMotion * (1 - i / 4));
                ctx.fillText(val, pad.left - 4, y + 3);
            }

            // X-axis time labels
            ctx.textAlign = 'center';
            const timeSteps = Math.min(6, Math.floor(duration / 30));
            for (let i = 0; i <= timeSteps; i++) {
                const t = (duration / timeSteps) * i;
                const x = pad.left + (t / duration) * plotW;
                ctx.fillText(formatTime(t), x, H - 3);
            }

            // Detection markers (vertical green lines)
            detections.forEach(t => {
                const x = pad.left + (t / duration) * plotW;
                ctx.strokeStyle = 'rgba(76, 175, 80, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x, pad.top);
                ctx.lineTo(x, pad.top + plotH);
                ctx.stroke();

                // Small triangle marker at top
                ctx.fillStyle = '#4CAF50';
                ctx.beginPath();
                ctx.moveTo(x - 4, pad.top);
                ctx.lineTo(x + 4, pad.top);
                ctx.lineTo(x, pad.top + 8);
                ctx.closePath();
                ctx.fill();
            });

            // Draw motion threshold line
            const motionThreshold = 12;
            const threshY = pad.top + plotH * (1 - motionThreshold / maxMotion);
            if (threshY > pad.top && threshY < pad.top + plotH) {
                ctx.strokeStyle = 'rgba(255, 82, 82, 0.6)';
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.moveTo(pad.left, threshY);
                ctx.lineTo(W - pad.right, threshY);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.fillStyle = 'rgba(255, 82, 82, 0.8)';
                ctx.textAlign = 'left';
                ctx.fillText('threshold', pad.left + 2, threshY - 3);
            }

            // Helper to draw a line series
            function drawLine(color, getValue, getMax) {
                ctx.strokeStyle = color;
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                let started = false;
                data.forEach((d, i) => {
                    const x = pad.left + (d.time / duration) * plotW;
                    const v = Math.min(1, getValue(d) / getMax);
                    const y = pad.top + plotH * (1 - v);
                    if (!started) { ctx.moveTo(x, y); started = true; }
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();
            }

            // Draw rim and ball as normalized against their own max
            drawLine('rgba(255, 138, 101, 0.7)', d => d.rim, maxRim);
            drawLine('rgba(255, 213, 79, 0.7)', d => d.ball, maxBall);
            // Draw motion last (on top) scaled to motion max
            drawLine('#4fc3f7', d => d.motion, maxMotion);
        }

        function updateMotionChart() {
            const duration = document.getElementById('processingVideo').duration || 1;
            drawMotionChart('motionChart', chartData, chartDetections, duration);
        }

        function drawFinalMotionChart() {
            const duration = document.getElementById('processingVideo').duration || 1;
            const container = document.getElementById('motionChartFinal');
            container.style.display = 'block';
            drawMotionChart('motionChartComplete', chartData, chartDetections, duration);
        }

        async function processVideo() {
            const video = document.getElementById('processingVideo'); // Use hidden video
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = 320;
            canvas.height = 180;
            
            highlights = [];
            chartData = [];
            chartDetections = [];
            document.getElementById('processBtn').disabled = true;
            document.getElementById('progressContainer').style.display = 'block';
            document.getElementById('highlightsSection').style.display = 'block';
            document.getElementById('motionChartFinal').style.display = 'none';

            const regionMsg = basketRegions.length > 0
                ? ` Detecting in ${basketRegions.length} region(s) using motion + color analysis.`
                : ' Using full-frame color detection (slower, less accurate).';
            showStatus('Processing video...' + regionMsg, 'processing');
            document.getElementById('motionThresholdLabel').textContent = '12';

            const duration = video.duration;
            const fps = 3;
            const interval = 1 / fps;

            let previousFrame = null;
            let motionHistory = [];
            let intensityHistory = [];
            let framesProcessed = 0;

            for (let time = 0; time < duration; time += interval) {
                video.currentTime = time;

                await new Promise(resolve => {
                    video.onseeked = () => resolve();
                });

                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                const currentFrame = ctx.getImageData(0, 0, canvas.width, canvas.height);

                if (previousFrame) {
                    const motion = detectMotion(previousFrame, currentFrame);
                    const rimScore = detectRimArea(currentFrame);
                    const ballScore = detectOrangeObject(currentFrame);

                    motionHistory.push(motion);
                    intensityHistory.push({ rim: rimScore, ball: ballScore });

                    // Record for chart
                    chartData.push({ time, motion, rim: rimScore, ball: ballScore, detected: false });
                    
                    // Keep last 15 frames (5 seconds at 3fps)
                    if (motionHistory.length > 15) {
                        motionHistory.shift();
                        intensityHistory.shift();
                    }
                    
                    // Detect potential basket
                    if (motionHistory.length >= 6) {
                        const detectionResult = calculateBasketScore(motionHistory, intensityHistory, time);
                        
                        if (detectionResult.passes) {
                            const lastHighlight = highlights[highlights.length - 1];
                            if (!lastHighlight || time - lastHighlight.timestamp > settings.minGap) {
                                // Mark on chart
                                chartDetections.push(time);
                                if (chartData.length > 0) chartData[chartData.length - 1].detected = true;

                                // Capture thumbnail with detection data
                                const thumbnail = captureThumbnail(video, canvas, ctx, {
                                    motion: detectionResult.motion,
                                    rim: detectionResult.rim,
                                    ball: detectionResult.ball,
                                    score: detectionResult.score,
                                    regionIndex: 0
                                });
                                
                                highlights.push({
                                    timestamp: time,
                                    confidence: Math.min(100, detectionResult.score),
                                    thumbnail: thumbnail,
                                    reasons: detectionResult.reasons,
                                    debugData: {
                                        motion: detectionResult.motion,
                                        rim: detectionResult.rim,
                                        ball: detectionResult.ball,
                                        motionDrop: detectionResult.motionDrop,
                                        rimVisible: detectionResult.rimVisible,
                                        ballPresent: detectionResult.ballPresent
                                    }
                                });
                                
                                // Update UI in real-time
                                updateHighlightsDisplay();
                                document.getElementById('basketsFound').textContent = highlights.length;
                                
                                // Start playing clips as soon as we get the first one
                                if (highlights.length === 1 && !isPlayingAll) {
                                    // Hide the setup guide
                                    document.getElementById('setupGuide').style.display = 'none';
                                    
                                    // Start playing immediately
                                    setTimeout(() => {
                                        playAllHighlights();
                                    }, 500); // Small delay to let UI update
                                }
                            }
                        }
                    }
                }
                
                previousFrame = currentFrame;
                framesProcessed++;
                
                const progress = Math.floor((time / duration) * 100);
                document.getElementById('progressFill').style.width = progress + '%';
                document.getElementById('progressText').textContent = progress + '%';
                document.getElementById('framesAnalyzed').textContent = framesProcessed;
                document.getElementById('currentProcessTime').textContent = formatTime(time);
                
                // Allow UI to update and redraw chart every 15 frames
                if (framesProcessed % 15 === 0) {
                    updateMotionChart();
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }
            
            document.getElementById('processBtn').disabled = false;
            document.getElementById('progressContainer').style.display = 'none';
            document.getElementById('setupGuide').style.display = 'none';
            drawFinalMotionChart();
            
            video.currentTime = 0;
            updateHighlightsDisplay();
            
            // Only auto-start if not already playing (might have started on first clip)
            if (highlights.length > 0 && !isPlayingAll) {
                showStatus(`Processing complete! Found ${highlights.length} clip(s). Playing now...`, 'complete');
                setTimeout(() => {
                    playAllHighlights();
                }, 1000);
            } else if (isPlayingAll) {
                showStatus(`Processing complete! Found ${highlights.length} clip(s) total.`, 'complete');
            } else {
                showStatus(`Processing complete! No clips detected.`, 'complete');
            }
        }

        function detectMotion(frame1, frame2) {
            const data1 = frame1.data;
            const data2 = frame2.data;
            let diff = 0;
            let count = 0;
            
            const width = frame1.width;
            const height = frame1.height;
            
            // If regions are set, analyze each region and return max motion
            if (basketRegions.length > 0) {
                let maxMotion = 0;
                
                basketRegions.forEach(region => {
                    const startX = Math.floor(region.x * width);
                    const startY = Math.floor(region.y * height);
                    const endX = Math.floor((region.x + region.width) * width);
                    const endY = Math.floor((region.y + region.height) * height);
                    
                    let regionDiff = 0;
                    let regionCount = 0;
                    
                    for (let y = startY; y < endY; y += 2) {
                        for (let x = startX; x < endX; x += 2) {
                            const idx = (y * width + x) * 4;
                            const r = Math.abs(data1[idx] - data2[idx]);
                            const g = Math.abs(data1[idx + 1] - data2[idx + 1]);
                            const b = Math.abs(data1[idx + 2] - data2[idx + 2]);
                            regionDiff += (r + g + b) / 3;
                            regionCount++;
                        }
                    }
                    
                    const regionMotion = regionCount > 0 ? regionDiff / regionCount : 0;
                    maxMotion = Math.max(maxMotion, regionMotion);
                });
                
                return maxMotion;
            } else {
                // Sample pixels across full frame
                for (let i = 0; i < data1.length; i += 40) {
                    const r = Math.abs(data1[i] - data2[i]);
                    const g = Math.abs(data1[i + 1] - data2[i + 1]);
                    const b = Math.abs(data1[i + 2] - data2[i + 2]);
                    diff += (r + g + b) / 3;
                    count++;
                }
                
                return diff / count;
            }
        }

        function detectRimArea(imageData) {
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            
            let orangeRedPixels = 0;
            let totalChecked = 0;
            
            if (basketRegions.length > 0) {
                // Analyze all regions and return max score
                let maxScore = 0;
                
                basketRegions.forEach(region => {
                    const startX = Math.floor(region.x * width);
                    const startY = Math.floor(region.y * height);
                    const endX = Math.floor((region.x + region.width) * width);
                    const endY = Math.floor((region.y + region.height) * height);
                    
                    let regionOrange = 0;
                    let regionChecked = 0;
                    
                    for (let y = startY; y < endY; y += 2) {
                        for (let x = startX; x < endX; x += 2) {
                            const idx = (y * width + x) * 4;
                            const r = data[idx];
                            const g = data[idx + 1];
                            const b = data[idx + 2];
                            
                            if (r > 140 && g > 40 && g < 160 && b < 100) {
                                regionOrange++;
                            }
                            regionChecked++;
                        }
                    }
                    
                    const regionScore = regionChecked > 0 ? (regionOrange / regionChecked) * 1000 : 0;
                    maxScore = Math.max(maxScore, regionScore);
                });
                
                return maxScore;
            } else {
                // Check top half for orange/red (rim)
                const topHalf = Math.floor(height / 2);
                
                for (let y = 0; y < topHalf; y += 2) {
                    for (let x = 0; x < width; x += 2) {
                        const idx = (y * width + x) * 4;
                        const r = data[idx];
                        const g = data[idx + 1];
                        const b = data[idx + 2];
                        
                        if (r > 140 && g > 40 && g < 160 && b < 100) {
                            orangeRedPixels++;
                        }
                        totalChecked++;
                    }
                }
                
                return (orangeRedPixels / totalChecked) * 1000;
            }
        }

        function detectOrangeObject(imageData) {
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            
            let orangePixels = 0;
            let totalChecked = 0;
            
            if (basketRegions.length > 0) {
                // Analyze all regions and return max score
                let maxScore = 0;
                
                basketRegions.forEach(region => {
                    const startX = Math.floor(region.x * width);
                    const startY = Math.floor(region.y * height);
                    const endX = Math.floor((region.x + region.width) * width);
                    const endY = Math.floor((region.y + region.height) * height);
                    
                    let regionOrange = 0;
                    let regionChecked = 0;
                    
                    for (let y = startY; y < endY; y += 2) {
                        for (let x = startX; x < endX; x += 2) {
                            const idx = (y * width + x) * 4;
                            const r = data[idx];
                            const g = data[idx + 1];
                            const b = data[idx + 2];
                            
                            if (r > 180 && g > 80 && g < 180 && b < 120 && r > g && g > b) {
                                regionOrange++;
                            }
                            regionChecked++;
                        }
                    }
                    
                    const regionScore = regionChecked > 0 ? (regionOrange / regionChecked) * 1000 : 0;
                    maxScore = Math.max(maxScore, regionScore);
                });
                
                return maxScore;
            } else {
                // Check middle area for orange ball
                const startY = Math.floor(height * 0.2);
                const endY = Math.floor(height * 0.8);
                
                for (let y = startY; y < endY; y += 2) {
                    for (let x = 0; x < width; x += 2) {
                        const idx = (y * width + x) * 4;
                        const r = data[idx];
                        const g = data[idx + 1];
                        const b = data[idx + 2];
                        
                        if (r > 180 && g > 80 && g < 180 && b < 120 && r > g && g > b) {
                            orangePixels++;
                        }
                        totalChecked++;
                    }
                }
                
                return (orangePixels / totalChecked) * 1000;
            }
        }

        function calculateBasketScore(motionHistory, intensityHistory, time) {
            const recentMotion = motionHistory.slice(-3);
            const earlierMotion = motionHistory.slice(-6, -3);

            const avgRecent = recentMotion.reduce((a, b) => a + b) / recentMotion.length;
            const avgEarlier = earlierMotion.length > 0
                ? earlierMotion.reduce((a, b) => a + b) / earlierMotion.length : 0;

            const recentIntensity = intensityHistory.slice(-3);
            const avgRim = recentIntensity.reduce((a, b) => a + b.rim, 0) / recentIntensity.length;
            const avgBall = recentIntensity.reduce((a, b) => a + b.ball, 0) / recentIntensity.length;

            // --- Motion pattern analysis ---
            // A basket is a short burst: motion spikes then drops within ~1-2s
            // A person walking is sustained motion over many frames
            const peak = Math.max(...motionHistory.slice(-6));
            const motionDrop = avgEarlier > 3 && avgRecent < avgEarlier * 0.6;
            const motionSpike = avgRecent > avgEarlier * 1.8 && avgRecent > 8;

            // Sustained motion check: if motion has been high for 4+ frames, likely a person
            const highMotionFrames = motionHistory.slice(-6).filter(m => m > 8).length;
            const sustainedMotion = highMotionFrames >= 5;

            // Color signals
            const rimVisible = avgRim > 5;
            const ballPresent = avgBall > 3;

            let score = 0;
            let reasons = [];

            if (basketRegions.length > 0) {
                // WITH REGIONS: require motion burst + at least one color signal
                // Higher motion threshold to filter out minor movements
                const motionAboveThreshold = avgRecent > 12;

                if (motionAboveThreshold && !sustainedMotion) {
                    score += 30;
                    reasons.push('Motion Burst');
                }

                // Motion spike or drop pattern (ball appearing/disappearing)
                if (motionSpike || motionDrop) {
                    score += 20;
                    reasons.push('Motion Pattern');
                }

                // Color signals contribute even in region mode
                if (rimVisible) {
                    score += 25;
                    reasons.push('Rim Detected');
                }
                if (ballPresent) {
                    score += 25;
                    reasons.push('Ball Present');
                }

                // Penalty for sustained motion (person walking through)
                if (sustainedMotion) {
                    score = Math.max(0, score - 40);
                    reasons.push('(sustained motion penalty)');
                }

                return {
                    score, motion: avgRecent, rim: avgRim, ball: avgBall,
                    motionDrop, rimVisible, ballPresent, reasons,
                    passes: score >= 50
                };
            }

            // NO REGIONS: full-frame mode (unchanged logic)
            if (motionDrop) {
                score += 30;
                reasons.push('Motion Drop');
            }
            if (rimVisible) {
                score += 40;
                reasons.push('Rim Detected');
            }
            if (ballPresent) {
                score += 30;
                reasons.push('Ball Present');
            }

            return {
                score, motion: avgRecent, rim: avgRim, ball: avgBall,
                motionDrop, rimVisible, ballPresent, reasons,
                passes: score >= 40
            };
        }

        function captureThumbnail(video, canvas, ctx, detectionData) {
            // Draw full frame first
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            
            // If there are regions, crop to show the region where detection happened
            if (basketRegions.length > 0) {
                const region = detectionData.regionIndex !== undefined 
                    ? basketRegions[detectionData.regionIndex] 
                    : basketRegions[0];
                
                const sx = Math.floor(region.x * canvas.width);
                const sy = Math.floor(region.y * canvas.height);
                const sw = Math.floor(region.width * canvas.width);
                const sh = Math.floor(region.height * canvas.height);
                
                // Create a thumbnail canvas
                const thumbCanvas = document.createElement('canvas');
                thumbCanvas.width = 320;
                thumbCanvas.height = 240;
                const thumbCtx = thumbCanvas.getContext('2d');
                
                // Draw the cropped region scaled to thumbnail size
                thumbCtx.drawImage(
                    video,
                    sx, sy, sw, sh,  // Source
                    0, 0, 320, 240   // Destination
                );
                
                // Add debug overlay showing detection scores
                thumbCtx.fillStyle = 'rgba(0, 0, 0, 0.75)';
                thumbCtx.fillRect(0, 200, 320, 40);
                
                thumbCtx.fillStyle = 'white';
                thumbCtx.font = 'bold 13px monospace';
                thumbCtx.fillText(`Motion: ${detectionData.motion.toFixed(1)}`, 8, 218);
                thumbCtx.fillText(`Rim: ${detectionData.rim.toFixed(1)}`, 8, 233);
                thumbCtx.fillText(`Ball: ${detectionData.ball.toFixed(1)}`, 168, 218);
                thumbCtx.fillText(`Score: ${detectionData.score.toFixed(0)}`, 168, 233);
                
                return thumbCanvas.toDataURL('image/jpeg', 0.8);
            }
            
            // Return full frame thumbnail if no regions
            const thumbCanvas = document.createElement('canvas');
            thumbCanvas.width = 320;
            thumbCanvas.height = 240;
            const thumbCtx = thumbCanvas.getContext('2d');
            thumbCtx.drawImage(canvas, 0, 0, 320, 240);
            
            // Add debug info
            thumbCtx.fillStyle = 'rgba(0, 0, 0, 0.75)';
            thumbCtx.fillRect(0, 200, 320, 40);
            thumbCtx.fillStyle = 'white';
            thumbCtx.font = 'bold 13px monospace';
            thumbCtx.fillText(`Motion: ${detectionData.motion.toFixed(1)}`, 8, 218);
            thumbCtx.fillText(`Rim: ${detectionData.rim.toFixed(1)}`, 8, 233);
            thumbCtx.fillText(`Ball: ${detectionData.ball.toFixed(1)}`, 168, 218);
            thumbCtx.fillText(`Score: ${detectionData.score.toFixed(0)}`, 168, 233);
            
            return thumbCanvas.toDataURL('image/jpeg', 0.8);
        }

        function updateHighlightsDisplay() {
            const section = document.getElementById('highlightsSection');
            const list = document.getElementById('highlightsList');
            const count = document.getElementById('highlightCount');
            
            if (highlights.length === 0) {
                section.style.display = 'none';
                return;
            }
            
            section.style.display = 'block';
            count.textContent = highlights.length + (highlights.length === 1 ? ' basket' : ' baskets');
            
            list.innerHTML = highlights.map((h, i) => {
                const reasons = h.reasons ? h.reasons.join(', ') : 'Unknown';
                const debugData = h.debugData || {};
                
                return `
                <div class="highlight-item" onclick="jumpToHighlight(${h.timestamp})" title="Click to play">
                    ${h.thumbnail ? `
                        <div class="highlight-thumbnail">
                            <img src="${h.thumbnail}" alt="Basket at ${formatTime(h.timestamp)}">
                            <div class="play-icon">‚ñ∂</div>
                        </div>
                    ` : ''}
                    <div class="highlight-number">${i + 1}</div>
                    <div class="highlight-info">
                        <div class="highlight-time">${formatTime(h.timestamp)}</div>
                        <div>
                            <span class="confidence">Score: ${Math.round(h.confidence)}</span>
                        </div>
                        <div style="font-size: 10px; color: #667eea; margin-top: 4px;">
                            ${reasons}
                        </div>
                        ${debugData.motion !== undefined ? `
                        <div style="font-size: 9px; color: #999; margin-top: 4px; font-family: monospace;">
                            M:${debugData.motion.toFixed(1)} 
                            R:${debugData.rim.toFixed(1)} 
                            B:${debugData.ball.toFixed(1)}
                            ${debugData.motionDrop ? 'üìâ' : ''}
                            ${debugData.rimVisible ? 'üéØ' : ''}
                            ${debugData.ballPresent ? 'üèÄ' : ''}
                        </div>
                        ` : ''}
                    </div>
                </div>
            `}).join('');
            
            // Show Play All button when highlights are available
            const playAllBtn = document.getElementById('playAllBtn');
            if (playAllBtn) {
                playAllBtn.style.display = highlights.length > 0 ? 'block' : 'none';
            }
            
            // Enable playback controls when highlights are available
            enablePlaybackControls();
        }

        function jumpToHighlight(timestamp) {
            const video = document.getElementById('videoPlayer');
            const startTime = Math.max(0, timestamp - 3); // Start 3 seconds before
            const endTime = timestamp + 1; // Stop 1 second after
            
            video.currentTime = startTime;
            video.play();
            
            // Set up listener to stop at end time
            const stopListener = () => {
                if (video.currentTime >= endTime) {
                    video.pause();
                    video.removeEventListener('timeupdate', stopListener);
                }
            };
            
            video.addEventListener('timeupdate', stopListener);
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            const ms = Math.floor((seconds % 1) * 10);
            return `${mins}:${secs.toString().padStart(2, '0')}.${ms}`;
        }

        function exportTimestamps() {
            const text = highlights.map((h, i) => 
                `${i + 1}. ${formatTime(h.timestamp)} (${Math.round(h.confidence)}% confidence)`
            ).join('\n');
            
            navigator.clipboard.writeText(text).then(() => {
                showStatus('Timestamps copied to clipboard!', 'complete');
            });
        }

        function exportJSON() {
            const data = {
                videoSource: currentTab === 'file' ? 'local file' : document.getElementById('videoUrl').value,
                processedDate: new Date().toISOString(),
                totalHighlights: highlights.length,
                highlights: highlights.map((h, i) => ({
                    number: i + 1,
                    timestamp: h.timestamp,
                    formattedTime: formatTime(h.timestamp),
                    confidence: Math.round(h.confidence)
                }))
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `basketball-highlights-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function playPreviousClip() {
            if (currentHighlightIndex > 0) {
                currentHighlightIndex--;
                playNextHighlight();
            }
        }

        function playNextClip() {
            if (currentHighlightIndex < highlights.length - 1) {
                currentHighlightIndex++;
                playNextHighlight();
            } else {
                // Loop back to start
                currentHighlightIndex = 0;
                playNextHighlight();
            }
        }

        function playAllHighlights() {
            if (highlights.length === 0) return;
            
            isPlayingAll = true;
            currentHighlightIndex = 0;
            
            playNextHighlight();
        }

        function playNextHighlight() {
            if (!isPlayingAll || currentHighlightIndex >= highlights.length) {
                stopPlayingAll();
                return;
            }
            
            const highlight = highlights[currentHighlightIndex];
            const video = document.getElementById('videoPlayer');
            
            // Show overlay
            const overlay = document.getElementById('videoOverlay');
            console.log('Showing overlay, element:', overlay);
            overlay.style.display = 'block';
            document.getElementById('overlayClipNumber').textContent = currentHighlightIndex + 1;
            document.getElementById('overlayTotalClips').textContent = highlights.length;
            document.getElementById('overlayTimestamp').textContent = formatTime(highlight.timestamp);
            console.log('Overlay should now be visible');
            
            // Highlight the current item in the list
            document.querySelectorAll('.highlight-item').forEach((item, idx) => {
                item.classList.toggle('playing', idx === currentHighlightIndex);
            });
            
            // Scroll to current highlight in theater mode WITHOUT focus jump
            if (isTheaterMode) {
                const currentItem = document.querySelectorAll('.highlight-item')[currentHighlightIndex];
                if (currentItem) {
                    const container = document.getElementById('highlightsList');
                    const itemRect = currentItem.getBoundingClientRect();
                    const containerRect = container.getBoundingClientRect();
                    
                    // Calculate scroll position to center the item
                    const scrollLeft = currentItem.offsetLeft - (containerRect.width / 2) + (itemRect.width / 2);
                    container.scrollLeft = scrollLeft;
                }
            }
            
            const startTime = Math.max(0, highlight.timestamp - 3);
            const endTime = highlight.timestamp + 1;
            const clipDuration = endTime - startTime;
            
            document.getElementById('overlayClipDuration').textContent = clipDuration.toFixed(1) + 's';
            
            video.currentTime = startTime;
            video.play();
            
            // Remove any existing listener
            if (playAllListener) {
                video.removeEventListener('timeupdate', playAllListener);
            }
            
            // Set up listener to move to next highlight and update progress
            playAllListener = () => {
                const elapsed = video.currentTime - startTime;
                const progress = Math.min(100, (elapsed / clipDuration) * 100);
                
                // Update overlay progress
                document.getElementById('overlayProgress').style.width = progress + '%';
                document.getElementById('overlayClipTime').textContent = elapsed.toFixed(1) + 's';
                
                if (video.currentTime >= endTime) {
                    video.removeEventListener('timeupdate', playAllListener);
                    currentHighlightIndex++;
                    
                    // Small pause between highlights
                    setTimeout(() => {
                        if (isPlayingAll) {
                            playNextHighlight();
                        }
                    }, 300);
                }
            };
            
            video.addEventListener('timeupdate', playAllListener);
        }

        function stopPlayingAll() {
            isPlayingAll = false;
            const video = document.getElementById('videoPlayer');
            
            if (playAllListener) {
                video.removeEventListener('timeupdate', playAllListener);
                playAllListener = null;
            }
            
            video.pause();
            
            // Hide overlay
            document.getElementById('videoOverlay').style.display = 'none';
            
            // Remove playing class from all items
            document.querySelectorAll('.highlight-item').forEach(item => {
                item.classList.remove('playing');
            });
        }

        function enablePlaybackControls() {
            // No longer needed - removed mode buttons
        }

        function setupKeyboardNavigation() {
            document.addEventListener('keydown', (e) => {
                // Only handle if we have highlights and not typing in an input
                if (highlights.length === 0 || e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                    return;
                }
                
                const video = document.getElementById('videoPlayer');
                
                switch(e.key) {
                    case 'ArrowRight':
                        e.preventDefault();
                        playNextClip();
                        break;
                        
                    case 'ArrowLeft':
                        e.preventDefault();
                        playPreviousClip();
                        break;
                        
                    case ' ':
                        e.preventDefault();
                        if (video.paused) {
                            if (!isPlayingAll && highlights.length > 0) {
                                playAllHighlights();
                            } else {
                                video.play();
                            }
                        } else {
                            video.pause();
                        }
                        break;
                }
            });
        }

        function showStatus(message, type) {
            // Status messages hidden - do nothing
            return;
        }
    </script>
</body>
</html>