<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Basketball Highlights Detector</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 32px;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 16px;
        }

        .content {
            padding: 30px;
        }

        .input-section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 12px;
            margin-bottom: 30px;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .tab {
            padding: 10px 20px;
            border: none;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .tab:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .tab.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        input[type="text"],
        input[type="file"] {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid #e1e8ed;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.2s;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .btn-primary:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: #e1e8ed;
            color: #333;
        }

        .btn-secondary:hover {
            background: #d1d8dd;
        }

        .video-section {
            display: grid;
            grid-template-columns: 1.5fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
            align-items: start;
        }

        @media (max-width: 968px) {
            .video-section {
                grid-template-columns: 1fr;
            }
        }

        /* Mobile-specific styles for phones */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .container {
                border-radius: 8px;
            }
            
            .header {
                padding: 15px 20px !important;
            }
            
            .header h1 {
                font-size: 20px !important;
            }
            
            .content {
                padding: 15px !important;
            }
            
            .upload-section {
                padding: 20px !important;
            }
            
            .tabs {
                flex-direction: column;
                gap: 8px;
            }
            
            .tab {
                width: 100%;
                justify-content: center;
            }
            
            .btn {
                padding: 12px 20px !important;
                font-size: 14px !important;
                width: 100%;
            }
            
            .video-section {
                padding: 15px !important;
            }
            
            .settings {
                padding: 15px !important;
            }
            
            /* Make sure video player is visible */
            .video-container {
                height: auto !important;
                min-height: 200px;
            }
            
            .video-container video {
                width: 100%;
                height: auto;
            }
            
            /* Stack highlights vertically on mobile */
            .highlights-container {
                max-height: none;
                overflow-y: auto;
            }
            
            .highlight-item {
                flex-direction: row;
                padding: 10px;
            }
            
            .highlight-thumbnail {
                width: 100px !important;
                height: 75px !important;
            }
            
            /* Make overlay more compact on mobile */
            #videoOverlay {
                padding: 8px 12px !important;
                font-size: 12px !important;
                bottom: 50px !important;
            }
            
            #videoOverlay button {
                width: 28px !important;
                height: 28px !important;
                font-size: 14px !important;
            }
            
            /* (setupGuide styles removed) */
        }

        @media (max-width: 480px) {
            body {
                padding: 5px;
            }
            
            .header h1 {
                font-size: 18px !important;
            }
            
            .content {
                padding: 10px !important;
            }
            
            .upload-section {
                padding: 15px !important;
            }
            
            /* Even more compact on very small screens */
            #videoOverlay {
                font-size: 11px !important;
                padding: 6px 10px !important;
            }
        }

        .video-column {
            position: sticky;
            top: 20px;
        }

        .video-section.theater-mode {
            grid-template-columns: 1fr;
            gap: 15px;
        }

        .video-section.theater-mode .video-column {
            position: relative;
        }

        .video-section.theater-mode .video-container {
            height: 70vh;
        }

        .video-section.theater-mode video {
            height: 100%;
            object-fit: contain;
        }

        .video-section.theater-mode #videoOverlay {
            bottom: 80px;
            font-size: 16px;
        }

        .video-section.theater-mode .highlights-container {
            max-height: none;
        }

        .video-section.theater-mode .highlights-list {
            display: flex;
            flex-direction: row;
            overflow-x: auto;
            overflow-y: hidden;
            gap: 12px;
            padding-bottom: 10px;
            scroll-behavior: smooth;
        }

        .video-section.theater-mode .highlight-item {
            flex-direction: column;
            min-width: 160px;
            max-width: 160px;
        }

        .video-section.theater-mode .highlight-thumbnail {
            width: 100%;
            height: 90px;
        }

        .highlight-item.playing {
            border-color: #667eea;
            background: #f0f4ff;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.3);
        }

        .video-container {
            background: #000;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }

        video {
            width: 100%;
            display: block;
        }

        canvas {
            display: none;
        }

        #selectionCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: default;
            display: none;
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
        }

        #selectionCanvas.active {
            display: block;
        }

        #selectionCanvas.has-regions {
            display: block;
            pointer-events: none;
        }

        .basket-overlay-controls {
            display: none;
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 200;
            gap: 10px;
            align-items: center;
        }

        .basket-overlay-controls.active {
            display: flex;
        }

        .basket-overlay-controls button {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .basket-overlay-controls .confirm-btn {
            background: #4CAF50;
            color: white;
        }

        .basket-overlay-controls .cancel-btn {
            background: rgba(255,255,255,0.9);
            color: #333;
        }

        .region-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .region-indicator {
            background: white;
            padding: 10px 12px;
            border-radius: 8px;
            font-size: 13px;
            color: #333;
            border: 2px solid #e1e8ed;
            flex: 1;
            min-width: 180px;
        }

        .region-indicator.set {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .region-indicator strong {
            color: #667eea;
            display: block;
            margin-bottom: 4px;
        }

        .region-badge {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            margin-left: 6px;
        }

        .help-text {
            font-size: 12px;
            color: #666;
            margin-top: 8px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 6px;
            border-left: 3px solid #667eea;
        }

        @keyframes fadeSlideIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes pulseGlow {
            0%, 100% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.5); }
            50% { box-shadow: 0 0 16px 4px rgba(76, 175, 80, 0.4); }
        }

        .highlights-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-height: calc(100vh - 100px);
            overflow-y: auto;
        }

        .highlights-list {
            display: grid;
            gap: 12px;
            max-height: none;
        }

        .progress-container {
            background: white;
            padding: 20px;
            border-radius: 12px;
            border: 2px solid #e1e8ed;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e1e8ed;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s;
        }

        .progress-text {
            text-align: center;
            color: #666;
            font-size: 14px;
        }

        .motion-chart-container {
            margin-top: 15px;
            background: #1a1a2e;
            border-radius: 8px;
            padding: 12px;
            position: relative;
        }

        .motion-chart-container canvas {
            display: block;
            width: 100%;
            height: 160px;
            border-radius: 4px;
        }

        .motion-chart-container h4 {
            color: #ccc;
            font-size: 12px;
            margin: 0 0 8px 0;
            font-weight: 600;
        }

        .motion-chart-legend {
            display: flex;
            gap: 12px;
            font-size: 10px;
            color: #aaa;
            margin-top: 6px;
            flex-wrap: wrap;
        }

        .motion-chart-legend span {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .motion-chart-legend .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
        }

        .status {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status.processing {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .status.complete {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .highlights-section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 12px;
        }

        .highlights-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .highlights-header h2 {
            font-size: 24px;
            color: #333;
        }

        .highlight-count {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
        }

        .highlights-list {
            display: grid;
            gap: 12px;
        }

        .highlight-item {
            background: white;
            padding: 12px;
            border-radius: 8px;
            display: flex;
            gap: 12px;
            align-items: center;
            transition: all 0.2s;
            cursor: pointer;
            border: 2px solid transparent;
        }

        .highlight-item:hover {
            border-color: #667eea;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
        }

        .highlight-thumbnail {
            width: 140px;
            height: 105px;
            background: #000;
            border-radius: 6px;
            overflow: hidden;
            flex-shrink: 0;
            position: relative;
        }

        .highlight-thumbnail img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .highlight-thumbnail .play-icon {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 24px;
            height: 24px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        .highlight-info {
            display: flex;
            flex-direction: column;
            gap: 4px;
            flex: 1;
        }

        .highlight-number {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
            flex-shrink: 0;
        }

        .highlight-time {
            font-size: 16px;
            font-weight: 600;
            color: #333;
        }

        .confidence {
            font-size: 11px;
            color: #666;
            background: #e1e8ed;
            padding: 3px 6px;
            border-radius: 4px;
            display: inline-block;
        }

        .region-label {
            font-size: 11px;
            color: #667eea;
            font-weight: 600;
        }

        .export-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px solid #e1e8ed;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #999;
        }

        .empty-state svg {
            width: 80px;
            height: 80px;
            margin-bottom: 20px;
            opacity: 0.3;
        }

        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 0.6s linear infinite;
        }

        /* Performance diagnostics panel */
        .perf-panel {
            margin-top: 12px;
            background: #1a1a2e;
            border-radius: 8px;
            overflow: hidden;
            font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
            font-size: 11px;
        }
        .perf-panel-toggle {
            width: 100%;
            padding: 8px 12px;
            background: #16213e;
            color: #a8b2d1;
            border: none;
            cursor: pointer;
            text-align: left;
            font-size: 11px;
            font-family: inherit;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .perf-panel-toggle:hover { background: #1a2744; }
        .perf-panel-body {
            padding: 10px 12px;
            color: #ccd6f6;
            line-height: 1.7;
            display: none;
        }
        .perf-panel-body.open { display: block; }
        .perf-row {
            display: flex;
            justify-content: space-between;
        }
        .perf-label { color: #8892b0; }
        .perf-val { color: #64ffda; font-weight: 600; }
        .perf-val.warn { color: #ffd166; }
        .perf-val.bad { color: #ff5252; }
        .perf-separator {
            border-top: 1px solid #233554;
            margin: 6px 0;
        }
        .slow-processing-banner {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 10px;
            padding: 14px 16px;
            margin-top: 12px;
            text-align: center;
        }
        .slow-processing-banner p {
            color: #664d03;
            font-size: 13px;
            margin-bottom: 10px;
            line-height: 1.4;
        }
        .slow-processing-banner button {
            background: #ffc107;
            color: #664d03;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 700;
            font-size: 14px;
            cursor: pointer;
        }
        .slow-processing-banner button:hover { background: #ffca2c; }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .settings {
            background: white;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
        }

        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .setting-row:last-child {
            margin-bottom: 0;
        }

        .setting-label {
            font-size: 14px;
            color: #333;
            font-weight: 500;
        }

        .setting-description {
            font-size: 12px;
            color: #666;
            margin-top: 4px;
        }

        input[type="range"] {
            width: 150px;
        }

        .setting-value {
            font-size: 14px;
            font-weight: 600;
            color: #667eea;
            min-width: 40px;
            text-align: right;
        }

        /* Highlight toggle switch */
        .highlight-toggle {
            position: relative;
            width: 40px;
            height: 22px;
            flex-shrink: 0;
        }

        .highlight-toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background: #ccc;
            border-radius: 22px;
            transition: 0.2s;
        }

        .toggle-slider:before {
            content: "";
            position: absolute;
            height: 16px;
            width: 16px;
            left: 3px;
            bottom: 3px;
            background: white;
            border-radius: 50%;
            transition: 0.2s;
        }

        .highlight-toggle input:checked + .toggle-slider {
            background: #667eea;
        }

        .highlight-toggle input:checked + .toggle-slider:before {
            transform: translateX(18px);
        }

        .highlight-item.disabled {
            opacity: 0.4;
            border-color: #e1e8ed !important;
            box-shadow: none !important;
        }

        .highlight-item.disabled .highlight-thumbnail {
            filter: grayscale(1);
        }

        /* Highlight action buttons */
        .highlight-actions {
            display: flex;
            gap: 6px;
            margin-top: 6px;
        }

        .highlight-actions button {
            padding: 4px 8px;
            border: 1px solid #e1e8ed;
            background: white;
            border-radius: 6px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 4px;
            color: #555;
        }

        .highlight-actions button:hover {
            border-color: #667eea;
            color: #667eea;
            background: #f0f4ff;
        }

        .highlight-actions button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .highlight-actions button.loading {
            pointer-events: none;
        }

        /* FFmpeg loading overlay */
        .ffmpeg-loading {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.6);
            z-index: 9999;
            justify-content: center;
            align-items: center;
        }

        .ffmpeg-loading.active {
            display: flex;
        }

        .ffmpeg-loading-card {
            background: white;
            padding: 30px;
            border-radius: 16px;
            text-align: center;
            max-width: 320px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        .ffmpeg-loading-card h3 {
            margin-bottom: 12px;
            color: #333;
        }

        .ffmpeg-loading-card .progress-bar {
            margin-bottom: 8px;
        }

        .ffmpeg-loading-card p {
            font-size: 13px;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üèÄ Basketball Highlights Detector</h1>
            <p>Automatically find made baskets in your pickup game videos</p>
        </div>

        <div class="content">
            <!-- Input Section -->
            <div class="input-section">
                <div class="tabs">
                    <button class="tab active" id="fileTab" onclick="switchTab('file')">Choose File</button>
                    <button class="tab" id="urlTab" onclick="switchTab('url')">Use URL</button>
                </div>

                <div id="fileInput">
                    <div class="input-group" style="flex-direction: column;">
                        <input type="file" id="videoFile" accept="video/*" onchange="handleFileUpload(event)">
                    </div>
                </div>

                <div id="urlInput" style="display: none;">
                    <div class="input-group" style="display: flex; gap: 8px;">
                        <input type="text" id="videoUrl" placeholder="Paste video URL or Google Drive link" onkeypress="if(event.key==='Enter') loadVideo()" style="flex: 1;">
                        <button class="btn btn-primary" onclick="loadVideo()" style="white-space: nowrap; padding: 10px 20px;">Load Video</button>
                    </div>
                    <p style="font-size: 12px; color: #666; margin-top: 8px;">
                        üí° For Google Drive: Share the video ‚Üí Get link ‚Üí Change to "Anyone with the link" ‚Üí Paste link above
                    </p>
                </div>
            </div>

            <!-- Settings panel removed -->

            <!-- Video Section -->
            <div class="video-section" id="videoSection" style="display: none;">
                <div class="video-column">
                    <!-- Setup guide (hidden) -->
                    <div id="setupGuide" style="display: none;"></div>
                    
                    <div class="video-container">
                        <video id="videoPlayer" controls></video>
                        <video id="processingVideo" style="display: none;"></video>
                        <canvas id="canvas"></canvas>
                        <canvas id="selectionCanvas"></canvas>
                        <div class="basket-overlay-controls" id="basketOverlayControls">
                            <button class="cancel-btn" onclick="cancelOverlaySelection()">Cancel</button>
                            <button class="confirm-btn" onclick="confirmOverlaySelection()">Confirm</button>
                        </div>

                        <!-- Simplified Video Overlay - positioned below video controls -->
                        <div id="videoOverlay" style="display: none; position: absolute; bottom: 60px; left: 10px; right: 10px; background: rgba(0, 0, 0, 0.8); padding: 12px 16px; border-radius: 8px; color: white; font-family: sans-serif; z-index: 100; pointer-events: auto;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div style="display: flex; align-items: center; gap: 15px;">
                                    <button onclick="playPreviousClip()" style="background: rgba(255,255,255,0.2); border: none; color: white; width: 32px; height: 32px; border-radius: 50%; cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center; pointer-events: auto;">
                                        ‚óÄ
                                    </button>
                                    <div>
                                        <div style="font-size: 14px; font-weight: 600;">
                                            Clip <span id="overlayClipNumber">1</span> of <span id="overlayTotalClips">0</span>
                                        </div>
                                        <div style="font-size: 11px; color: #ddd; margin-top: 2px;">
                                            <span id="overlayTimestamp">0:00</span> ‚Ä¢ <span id="overlayClipTime">0.0s</span>/<span id="overlayClipDuration">4.0s</span>
                                        </div>
                                    </div>
                                    <button onclick="playNextClip()" style="background: rgba(255,255,255,0.2); border: none; color: white; width: 32px; height: 32px; border-radius: 50%; cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center; pointer-events: auto;">
                                        ‚ñ∂
                                    </button>
                                </div>
                                <div style="flex: 1; margin: 0 15px;">
                                    <div style="width: 100%; height: 4px; background: rgba(255, 255, 255, 0.3); border-radius: 2px; overflow: hidden;">
                                        <div id="overlayProgress" style="width: 0%; height: 100%; background: linear-gradient(90deg, #667eea 0%, #764ba2 100%); transition: width 0.1s linear;"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="region-controls">
                        <div class="region-indicator" id="regionIndicator">
                            <strong>üéØ Basket Regions:</strong>
                            <div id="regionList">None selected</div>
                        </div>
                    </div>
                    <div style="display: flex; gap: 10px; margin-top: 10px;">
                        <button class="btn btn-primary" onclick="startRegionSelection()" id="selectRegionBtn" style="flex: 1;">
                            üìç Add Basket Region
                        </button>
                        <button class="btn btn-secondary" onclick="clearLastRegion()" id="clearRegionBtn" style="display: none;">
                            ‚úï Remove
                        </button>
                    </div>
                    <div class="help-text" id="regionHelp" style="display: none; background: #f0f4ff; padding: 12px; border-radius: 8px; margin-top: 10px; font-size: 13px; color: #333;">
                        <strong>Drag the box</strong> over the basket, then <strong>drag corners</strong> to resize. Tap <strong>Confirm</strong> when done.
                    </div>
                    
                    <button class="btn btn-primary" onclick="processVideo()" id="processBtn" style="margin-top: 15px; width: 100%; display: none;">
                        <span>‚ñ∂ Play Clips</span>
                    </button>
                    
                    <button class="btn btn-primary" onclick="playAllHighlights()" id="playAllBtn" style="margin-top: 10px; width: 100%; display: none; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                        <span>‚ñ∂ Play All Highlights</span>
                    </button>
                </div>

                <div class="highlights-container">
                    <div class="progress-container" id="progressContainer" style="display: none;">
                        <h3 style="margin-bottom: 15px;">Processing...</h3>
                        <div class="progress-bar">
                            <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                        </div>
                        <div class="progress-text" id="progressText">0%</div>
                        <div style="font-size: 13px; color: #333; margin-top: 15px; padding: 12px; background: white; border-radius: 8px;">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                <span>üé¨ Frames Analyzed:</span>
                                <strong id="framesAnalyzed">0</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                <span>üèÄ Baskets Found:</span>
                                <strong id="basketsFound">0</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between;">
                                <span>‚è±Ô∏è Current Time:</span>
                                <strong id="currentProcessTime">0:00</strong>
                            </div>
                        </div>
                        <p style="font-size: 12px; color: #666; margin-top: 10px; text-align: center;">
                            üí° You can watch the main video while processing continues
                        </p>

                        <!-- Performance diagnostics panel -->
                        <div class="perf-panel" id="perfPanel">
                            <button class="perf-panel-toggle" onclick="document.getElementById('perfPanelBody').classList.toggle('open'); this.querySelector('.arrow').textContent = document.getElementById('perfPanelBody').classList.contains('open') ? '‚ñº' : '‚ñ∂';">
                                ‚ö° Performance Diagnostics <span class="arrow">‚ñ∂</span>
                            </button>
                            <div class="perf-panel-body" id="perfPanelBody">
                                <div class="perf-row"><span class="perf-label">Video codec:</span><span class="perf-val" id="perfCodec">‚Äî</span></div>
                                <div class="perf-row"><span class="perf-label">Video resolution:</span><span class="perf-val" id="perfResolution">‚Äî</span></div>
                                <div class="perf-row"><span class="perf-label">Video duration:</span><span class="perf-val" id="perfDuration">‚Äî</span></div>
                                <div class="perf-separator"></div>
                                <div class="perf-row"><span class="perf-label">Frames processed:</span><span class="perf-val" id="perfFrameCount">0</span></div>
                                <div class="perf-row"><span class="perf-label">Elapsed time:</span><span class="perf-val" id="perfElapsed">0s</span></div>
                                <div class="perf-row"><span class="perf-label">Effective FPS:</span><span class="perf-val" id="perfFPS">‚Äî</span></div>
                                <div class="perf-separator"></div>
                                <div class="perf-row"><span class="perf-label">Avg seek time:</span><span class="perf-val" id="perfSeekAvg">‚Äî</span></div>
                                <div class="perf-row"><span class="perf-label">Min / Max seek:</span><span class="perf-val" id="perfSeekRange">‚Äî</span></div>
                                <div class="perf-row"><span class="perf-label">Seek timeouts (5s):</span><span class="perf-val" id="perfSeekTimeouts">0</span></div>
                                <div class="perf-row"><span class="perf-label">Slow seeks (>500ms):</span><span class="perf-val" id="perfSlowSeeks">0</span></div>
                                <div class="perf-separator"></div>
                                <div class="perf-row"><span class="perf-label">Avg draw+read time:</span><span class="perf-val" id="perfDrawAvg">‚Äî</span></div>
                                <div class="perf-row"><span class="perf-label">Avg motion calc:</span><span class="perf-val" id="perfMotionAvg">‚Äî</span></div>
                                <div class="perf-row"><span class="perf-label">Avg total/frame:</span><span class="perf-val" id="perfFrameAvg">‚Äî</span></div>
                                <div class="perf-separator"></div>
                                <div class="perf-row"><span class="perf-label">Last 10 seeks (ms):</span></div>
                                <div id="perfSeekHistory" style="color: #64ffda; word-break: break-all; margin-top: 2px;">‚Äî</div>
                            </div>
                        </div>
                    </div>

                    <!-- Motion chart - single persistent element, visible once processing starts -->
                    <div class="motion-chart-container" id="motionChartContainer" style="display: none;">
                        <h4>Motion Analysis</h4>
                        <canvas id="motionChart"></canvas>
                        <div class="motion-chart-legend" id="motionChartLegend">
                            <span><span class="dot" style="background: #4fc3f7;"></span> Motion</span>
                            <span><span class="dot" style="background: rgba(255,82,82,0.6);"></span> Threshold</span>
                            <span><span class="dot" style="background: #4CAF50;"></span> Detection</span>
                        </div>
                    </div>

                    <!-- Highlights Section -->
                    <div class="highlights-section" id="highlightsSection" style="display: none;">
                        <div class="highlights-header">
                            <h2>Detected Highlights</h2>
                            <span class="highlight-count" id="highlightCount">0 baskets</span>
                        </div>
                        
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 6px; margin-bottom: 12px; font-size: 11px; color: #666;">
                            <strong>Debug:</strong> Anomaly Burst = brief spike above dynamic threshold | Sharp Spike = sudden 2x increase
                        </div>

                        <div class="highlights-list" id="highlightsList"></div>

                        <div class="export-section" style="display: flex; flex-wrap: wrap; gap: 8px;">
                            <button class="btn btn-secondary" onclick="exportTimestamps()">
                                üìã Copy Timestamps
                            </button>
                            <button class="btn btn-secondary" onclick="exportJSON()">
                                üíæ Download JSON
                            </button>
                            <button class="btn btn-secondary" onclick="exportClip()" id="exportClipBtn">
                                üé¨ Export Clips
                            </button>
                            <button class="btn btn-secondary" onclick="shareHighlights()" id="shareBtn" style="display: none;">
                                üì§ Share
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Status Messages -->
            <div id="statusMessage" style="display: none;"></div>

            <!-- FFmpeg Loading Overlay -->
            <div class="ffmpeg-loading" id="ffmpegLoading">
                <div class="ffmpeg-loading-card">
                    <h3 id="ffmpegLoadingTitle">Loading Video Editor...</h3>
                    <div class="progress-bar">
                        <div class="progress-fill" id="ffmpegProgressFill" style="width: 0%"></div>
                    </div>
                    <p id="ffmpegLoadingText">Downloading FFmpeg (~30 MB, first time only)</p>
                </div>
            </div>

            <!-- Empty State -->
            <div class="empty-state" id="emptyState">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"></circle>
                    <polygon points="10 8 16 12 10 16 10 8"></polygon>
                </svg>
                <h3>No video loaded</h3>
                <p>Upload a video file or paste a URL to get started</p>
            </div>
        </div>
    </div>

    <script>
        let currentTab = 'file';
        let videoFile = null;
        let highlights = [];
        let settings = {
            minGap: 3  // Minimum gap between clips in seconds
        };

        // Region selection variables - now supports multiple regions
        let basketRegions = [];
        let isSelectingRegion = false;
        let selectionCanvas = null;
        let selectionCtx = null;
        const MAX_REGIONS = 2;

        // Playback mode variables
        let isPlayingAll = false;
        let currentHighlightIndex = 0;
        let isTheaterMode = false;
        let playAllListener = null;

        // Motion chart data
        let chartData = [];        // {time, motions[], thresholds[], detected}
        let chartDetections = [];  // timestamps where detections fired

        // EMA anomaly detection state ‚Äî per region
        const EMA_ALPHA = 0.08;    // Smoothing factor ‚Äî lower = slower adaptation
        const ANOMALY_K = 2.5;     // Std deviations above mean to trigger
        const CEILING_K = 6;       // Motion above threshold * this = too big (person)
        const MIN_THRESHOLD = 2.5; // Floor so tiny noise doesn't trigger in dead-still scenes
        let regionEMAs = [];       // [{mean, variance, initialized}] per region

        // FFmpeg state
        let ffmpegInstance = null;
        let ffmpegLoaded = false;
        let ffmpegLoading = false;
        // videoDataForFFmpeg removed ‚Äî reading fresh from File each time
        // avoids keeping the entire video permanently in JS heap memory

        // Performance diagnostics state
        let perfStats = null;

        function resetPerfStats() {
            perfStats = {
                startTime: 0,
                frameCount: 0,
                seekTimes: [],       // all seek durations in ms
                seekTimeouts: 0,     // seeks that hit the 5s timeout
                drawTimes: [],       // drawImage + getImageData durations
                motionTimes: [],     // motion detection durations
                frameTimes: [],      // total per-frame durations
                lastSeeks: [],       // last 10 seek times for live view
            };
        }

        function updatePerfUI() {
            if (!perfStats || perfStats.frameCount === 0) return;
            const s = perfStats;
            const elapsed = (performance.now() - s.startTime) / 1000;
            const avg = arr => arr.length ? (arr.reduce((a, b) => a + b, 0) / arr.length) : 0;
            const min = arr => arr.length ? Math.min(...arr) : 0;
            const max = arr => arr.length ? Math.max(...arr) : 0;

            const seekAvg = avg(s.seekTimes);
            const seekMin = min(s.seekTimes);
            const seekMax = max(s.seekTimes);
            const slowSeeks = s.seekTimes.filter(t => t > 500).length;

            document.getElementById('perfFrameCount').textContent = s.frameCount;
            document.getElementById('perfElapsed').textContent = elapsed.toFixed(1) + 's';
            document.getElementById('perfFPS').textContent = (s.frameCount / elapsed).toFixed(2);

            const seekAvgEl = document.getElementById('perfSeekAvg');
            seekAvgEl.textContent = seekAvg.toFixed(1) + 'ms';
            seekAvgEl.className = 'perf-val' + (seekAvg > 500 ? ' bad' : seekAvg > 200 ? ' warn' : '');

            document.getElementById('perfSeekRange').textContent = seekMin.toFixed(0) + ' / ' + seekMax.toFixed(0) + 'ms';

            const toEl = document.getElementById('perfSeekTimeouts');
            toEl.textContent = s.seekTimeouts;
            toEl.className = 'perf-val' + (s.seekTimeouts > 0 ? ' bad' : '');

            const slowEl = document.getElementById('perfSlowSeeks');
            slowEl.textContent = slowSeeks;
            slowEl.className = 'perf-val' + (slowSeeks > 10 ? ' bad' : slowSeeks > 0 ? ' warn' : '');

            document.getElementById('perfDrawAvg').textContent = avg(s.drawTimes).toFixed(1) + 'ms';
            document.getElementById('perfMotionAvg').textContent = avg(s.motionTimes).toFixed(1) + 'ms';

            const frameAvgEl = document.getElementById('perfFrameAvg');
            const frameAvg = avg(s.frameTimes);
            frameAvgEl.textContent = frameAvg.toFixed(1) + 'ms';
            frameAvgEl.className = 'perf-val' + (frameAvg > 1000 ? ' bad' : frameAvg > 400 ? ' warn' : '');

            // Last 10 seeks with color coding
            const histEl = document.getElementById('perfSeekHistory');
            histEl.innerHTML = s.lastSeeks.map(t => {
                const color = t >= 4900 ? '#ff5252' : t > 500 ? '#ffd166' : '#64ffda';
                return `<span style="color:${color}">${t.toFixed(0)}</span>`;
            }).join(', ');
        }

        async function probeVideoInfo(video) {
            // Try to get codec info via VideoPlaybackQuality or MediaCapabilities
            const el = document.getElementById('perfResolution');
            el.textContent = video.videoWidth + 'x' + video.videoHeight;
            document.getElementById('perfDuration').textContent = video.duration.toFixed(1) + 's';

            // Try to detect codec from the source
            let codecInfo = 'unknown';
            try {
                // Use video.getVideoPlaybackQuality if available
                if (video.getVideoPlaybackQuality) {
                    const q = video.getVideoPlaybackQuality();
                    codecInfo = `dropped: ${q.droppedVideoFrames}/${q.totalVideoFrames}`;
                }
            } catch (e) {}

            // Try MediaSource.isTypeSupported to guess codec
            if (videoFile && videoFile.type) {
                codecInfo = videoFile.type;
            }
            document.getElementById('perfCodec').textContent = codecInfo;
        }

        // Ensure the video element is fully buffered and the decoder is warmed up.
        // On mobile, the browser may have metadata but not the actual video data yet,
        // causing extremely slow seeks during processing.
        async function warmUpVideo(video, statusMsg) {
            // Step 1: Wait for enough data to play through
            if (video.readyState < 4) { // HAVE_ENOUGH_DATA
                showStatus(statusMsg + ' Buffering video...', 'processing');
                await new Promise((resolve) => {
                    // Check if we already have enough data
                    if (video.readyState >= 3) { resolve(); return; } // HAVE_FUTURE_DATA is acceptable
                    const onReady = () => {
                        if (video.readyState >= 3) {
                            video.removeEventListener('canplay', onReady);
                            video.removeEventListener('canplaythrough', onReady);
                            video.removeEventListener('loadeddata', onReady);
                            clearTimeout(fallback);
                            resolve();
                        }
                    };
                    video.addEventListener('canplay', onReady);
                    video.addEventListener('canplaythrough', onReady);
                    video.addEventListener('loadeddata', onReady);
                    // Don't wait forever ‚Äî 10s max, then proceed anyway
                    const fallback = setTimeout(() => {
                        video.removeEventListener('canplay', onReady);
                        video.removeEventListener('canplaythrough', onReady);
                        video.removeEventListener('loadeddata', onReady);
                        console.warn('[Perf] Video warmup timed out at readyState:', video.readyState);
                        resolve();
                    }, 10000);
                });
            }

            // Step 2: Prime the decoder by seeking to frame 0 and waiting for it to render.
            // This forces the browser to parse the keyframe index and decode the first frame.
            showStatus(statusMsg + ' Warming up decoder...', 'processing');
            video.currentTime = 0.001; // Tiny offset to force a real seek
            await new Promise((resolve) => {
                let resolved = false;
                const done = () => { if (!resolved) { resolved = true; resolve(); } };
                const timeout = setTimeout(done, 5000);
                video.addEventListener('seeked', () => { clearTimeout(timeout); done(); }, { once: true });
            });

            console.log('[Perf] Video warmed up. readyState:', video.readyState,
                'buffered ranges:', video.buffered.length > 0
                    ? Array.from({length: video.buffered.length}, (_, i) =>
                        `${video.buffered.start(i).toFixed(1)}-${video.buffered.end(i).toFixed(1)}s`).join(', ')
                    : 'none');
        }

        function switchTab(tab) {
            currentTab = tab;
            document.getElementById('fileTab').classList.toggle('active', tab === 'file');
            document.getElementById('urlTab').classList.toggle('active', tab === 'url');
            document.getElementById('fileInput').style.display = tab === 'file' ? 'block' : 'none';
            document.getElementById('urlInput').style.display = tab === 'url' ? 'block' : 'none';
        }

        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (file) {
                videoFile = file;
                loadVideo();
            }
        }

        function loadVideo() {
            const video = document.getElementById('videoPlayer');
            const processingVideo = document.getElementById('processingVideo');

            if (currentTab === 'file' && videoFile) {
                const url = URL.createObjectURL(videoFile);
                video.removeAttribute('crossorigin');
                processingVideo.removeAttribute('crossorigin');
                video.src = url;
                processingVideo.src = url;
            } else if (currentTab === 'url') {
                let url = document.getElementById('videoUrl').value.trim();
                if (!url) {
                    showStatus('Please enter a video URL.', 'error');
                    return;
                }

                // Handle Google Drive links
                const isGoogleDrive = url.includes('drive.google.com') || url.includes('drive.usercontent.google.com');
                if (isGoogleDrive) {
                    const fileId = extractGoogleDriveId(url);
                    if (fileId) {
                        url = `https://drive.usercontent.google.com/download?id=${fileId}&export=download&confirm=t`;
                    } else {
                        showStatus('Could not extract file ID from Google Drive link. Make sure the link is a valid sharing URL.', 'error');
                        return;
                    }
                }

                showStatus('Loading video...', 'processing');

                video.src = url;
                processingVideo.src = url;
            }

            // Timeout for URL loading
            let loadTimeout = null;
            if (currentTab === 'url') {
                loadTimeout = setTimeout(() => {
                    const isGD = document.getElementById('videoUrl').value.includes('drive.google');
                    if (isGD) {
                        showStatus('Google Drive video is taking too long to load. The file may not be publicly shared, or Google may be blocking direct access. Try downloading the video and uploading it as a local file instead.', 'error');
                    } else {
                        showStatus('Video is taking too long to load. Check the URL and try again.', 'error');
                    }
                }, 20000);
            }

            video.onloadedmetadata = () => {
                if (loadTimeout) clearTimeout(loadTimeout);
                document.getElementById('emptyState').style.display = 'none';
                document.getElementById('videoSection').style.display = 'grid';
                highlights = [];
                basketRegions = [];
                // (video data is read fresh each export ‚Äî no cache to clear)
                _slowRetryCount = 0;       // Reset slow-processing retry counter
                updateHighlightsDisplay();
                updateRegionDisplay();

                // Initialize selection canvas
                initSelectionCanvas();

                // Set up keyboard navigation
                setupKeyboardNavigation();

                // Force first frame to render (prevents black preview on mobile).
                // A black preview means the decoder hasn't parsed the video data yet,
                // which would cause extremely slow seeking during processing.
                video.currentTime = 0.001;
                processingVideo.currentTime = 0.001;

                showStatus('Video loaded successfully! Select basket regions to start.', 'complete');
            };

            video.onerror = () => {
                if (loadTimeout) clearTimeout(loadTimeout);
                const urlInput = document.getElementById('videoUrl').value || '';
                if (urlInput.includes('drive.google')) {
                    showStatus('Could not load Google Drive video. Make sure the file is set to "Anyone with the link can view" and try again. If it still fails, download the video and upload it as a local file.', 'error');
                } else {
                    showStatus('Error loading video. Check the URL or file format.', 'error');
                }
            };
        }

        function extractGoogleDriveId(url) {
            const patterns = [
                /\/d\/([a-zA-Z0-9-_]+)/,
                /id=([a-zA-Z0-9-_]+)/,
                /\/file\/d\/([a-zA-Z0-9-_]+)/
            ];

            for (const pattern of patterns) {
                const match = url.match(pattern);
                if (match) return match[1];
            }
            return null;
        }

        function updateSettings() {
            // Settings UI removed ‚Äî minGap uses default value
        }

        function initSelectionCanvas() {
            const video = document.getElementById('videoPlayer');
            selectionCanvas = document.getElementById('selectionCanvas');
            selectionCtx = selectionCanvas.getContext('2d');

            // Match canvas size to video element
            const updateCanvasSize = () => {
                const rect = video.getBoundingClientRect();
                selectionCanvas.width = rect.width;
                selectionCanvas.height = rect.height;
                redrawRegion();
            };

            updateCanvasSize();
            window.addEventListener('resize', updateCanvasSize);

            // Interaction handlers for draggable overlay
            selectionCanvas.addEventListener('mousedown', handleOverlayPointerDown);
            selectionCanvas.addEventListener('mousemove', handleOverlayPointerMove);
            selectionCanvas.addEventListener('mouseup', handleOverlayPointerUp);
            selectionCanvas.addEventListener('touchstart', handleOverlayPointerDown, { passive: false });
            selectionCanvas.addEventListener('touchmove', handleOverlayPointerMove, { passive: false });
            selectionCanvas.addEventListener('touchend', handleOverlayPointerUp, { passive: false });
        }

        // Draggable/resizable overlay state
        let overlayRegion = null;      // The region being edited {x, y, width, height} in normalized coords
        let overlayDragType = null;    // 'move', 'tl', 'tr', 'bl', 'br' (corners)
        let overlayDragStart = null;   // {x, y} in normalized coords where drag started
        let overlayOriginal = null;    // Copy of region at drag start
        const HANDLE_SIZE = 22;        // px ‚Äî touch-friendly handle radius
        const MIN_REGION_SIZE = 0.08;  // Minimum 8% of video in either dimension

        function getPointerPos(e) {
            const rect = selectionCanvas.getBoundingClientRect();
            const touch = e.touches ? e.touches[0] : (e.changedTouches ? e.changedTouches[0] : e);
            return {
                px: (touch.clientX || e.clientX) - rect.left,
                py: (touch.clientY || e.clientY) - rect.top,
                nx: ((touch.clientX || e.clientX) - rect.left) / selectionCanvas.width,
                ny: ((touch.clientY || e.clientY) - rect.top) / selectionCanvas.height
            };
        }

        function hitTestOverlay(px, py) {
            if (!overlayRegion) return null;
            const r = overlayRegion;
            const x = r.x * selectionCanvas.width;
            const y = r.y * selectionCanvas.height;
            const w = r.width * selectionCanvas.width;
            const h = r.height * selectionCanvas.height;
            const hs = HANDLE_SIZE;

            // Test corners first (larger hit area for touch)
            if (Math.abs(px - x) < hs && Math.abs(py - y) < hs) return 'tl';
            if (Math.abs(px - (x + w)) < hs && Math.abs(py - y) < hs) return 'tr';
            if (Math.abs(px - x) < hs && Math.abs(py - (y + h)) < hs) return 'bl';
            if (Math.abs(px - (x + w)) < hs && Math.abs(py - (y + h)) < hs) return 'br';

            // Test inside box for move
            if (px >= x && px <= x + w && py >= y && py <= y + h) return 'move';

            return null;
        }

        function handleOverlayPointerDown(e) {
            if (!isSelectingRegion || !overlayRegion) return;
            e.preventDefault();
            const pos = getPointerPos(e);
            const hit = hitTestOverlay(pos.px, pos.py);
            if (!hit) return;

            overlayDragType = hit;
            overlayDragStart = { nx: pos.nx, ny: pos.ny };
            overlayOriginal = { ...overlayRegion };
        }

        function handleOverlayPointerMove(e) {
            if (!isSelectingRegion || !overlayRegion) return;
            e.preventDefault();
            const pos = getPointerPos(e);

            if (!overlayDragType) {
                // Update cursor based on hover
                const hit = hitTestOverlay(pos.px, pos.py);
                if (hit === 'move') selectionCanvas.style.cursor = 'grab';
                else if (hit) selectionCanvas.style.cursor = 'nwse-resize';
                else selectionCanvas.style.cursor = 'default';
                return;
            }

            // Active drag
            selectionCanvas.style.cursor = overlayDragType === 'move' ? 'grabbing' : 'nwse-resize';
            const dx = pos.nx - overlayDragStart.nx;
            const dy = pos.ny - overlayDragStart.ny;
            const o = overlayOriginal;

            if (overlayDragType === 'move') {
                overlayRegion.x = Math.max(0, Math.min(1 - o.width, o.x + dx));
                overlayRegion.y = Math.max(0, Math.min(1 - o.height, o.y + dy));
            } else {
                // Corner resize
                let newX = o.x, newY = o.y, newW = o.width, newH = o.height;

                if (overlayDragType === 'tl') {
                    newX = o.x + dx;
                    newY = o.y + dy;
                    newW = o.width - dx;
                    newH = o.height - dy;
                } else if (overlayDragType === 'tr') {
                    newY = o.y + dy;
                    newW = o.width + dx;
                    newH = o.height - dy;
                } else if (overlayDragType === 'bl') {
                    newX = o.x + dx;
                    newW = o.width - dx;
                    newH = o.height + dy;
                } else if (overlayDragType === 'br') {
                    newW = o.width + dx;
                    newH = o.height + dy;
                }

                // Enforce minimum size
                if (newW >= MIN_REGION_SIZE && newH >= MIN_REGION_SIZE) {
                    overlayRegion.x = Math.max(0, Math.min(1 - MIN_REGION_SIZE, newX));
                    overlayRegion.y = Math.max(0, Math.min(1 - MIN_REGION_SIZE, newY));
                    overlayRegion.width = Math.min(newW, 1 - overlayRegion.x);
                    overlayRegion.height = Math.min(newH, 1 - overlayRegion.y);
                }
            }

            drawOverlay();
        }

        function handleOverlayPointerUp(e) {
            if (!isSelectingRegion) return;
            e.preventDefault();
            overlayDragType = null;
            overlayDragStart = null;
            overlayOriginal = null;
            if (overlayRegion) {
                const hit = hitTestOverlay(getPointerPos(e).px, getPointerPos(e).py);
                selectionCanvas.style.cursor = hit === 'move' ? 'grab' : (hit ? 'nwse-resize' : 'default');
            }
        }

        function drawOverlay() {
            if (!selectionCanvas) return;
            selectionCtx.clearRect(0, 0, selectionCanvas.width, selectionCanvas.height);

            // Dark overlay
            selectionCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            selectionCtx.fillRect(0, 0, selectionCanvas.width, selectionCanvas.height);

            if (!overlayRegion) return;

            const r = overlayRegion;
            const x = r.x * selectionCanvas.width;
            const y = r.y * selectionCanvas.height;
            const w = r.width * selectionCanvas.width;
            const h = r.height * selectionCanvas.height;

            const colors = ['#667eea', '#f5576c'];
            const color = colors[basketRegions.length % colors.length];

            // Clear the region area (make it bright/visible)
            selectionCtx.clearRect(x, y, w, h);

            // Draw border
            selectionCtx.strokeStyle = color;
            selectionCtx.lineWidth = 3;
            selectionCtx.strokeRect(x, y, w, h);

            // Draw corner handles
            const hs = 12; // visual handle half-size
            const corners = [
                [x, y], [x + w, y],
                [x, y + h], [x + w, y + h]
            ];
            corners.forEach(([cx, cy]) => {
                selectionCtx.fillStyle = 'white';
                selectionCtx.beginPath();
                selectionCtx.arc(cx, cy, hs, 0, Math.PI * 2);
                selectionCtx.fill();
                selectionCtx.strokeStyle = color;
                selectionCtx.lineWidth = 3;
                selectionCtx.stroke();
            });

            // Draw label
            const label = `BASKET ${basketRegions.length + 1}`;
            selectionCtx.font = 'bold 12px sans-serif';
            const textWidth = selectionCtx.measureText(label).width;
            selectionCtx.fillStyle = color;
            selectionCtx.fillRect(x, y - 24, textWidth + 10, 22);
            selectionCtx.fillStyle = 'white';
            selectionCtx.fillText(label, x + 5, y - 9);
        }

        function toggleRegionSelection() {
            if (basketRegions.length >= MAX_REGIONS && !isSelectingRegion) {
                return;
            }

            isSelectingRegion = !isSelectingRegion;

            const canvas = document.getElementById('selectionCanvas');
            const btn = document.getElementById('selectRegionBtn');
            const help = document.getElementById('regionHelp');
            const overlayControls = document.getElementById('basketOverlayControls');

            if (isSelectingRegion) {
                canvas.classList.add('active');
                canvas.classList.remove('has-regions');
                btn.textContent = '‚úï Cancel Selection';
                btn.classList.remove('btn-secondary');
                btn.classList.add('btn-primary');
                help.style.display = 'block';
                overlayControls.classList.add('active');
                document.getElementById('videoPlayer').pause();

                // Create a default overlay region centered on the video
                overlayRegion = { x: 0.35, y: 0.25, width: 0.30, height: 0.35 };
                drawOverlay();
            } else {
                canvas.classList.remove('active');
                if (basketRegions.length > 0) canvas.classList.add('has-regions');
                btn.textContent = 'üìç Add Basket Region';
                btn.classList.remove('btn-primary');
                btn.classList.add('btn-secondary');
                help.style.display = 'none';
                overlayControls.classList.remove('active');
                overlayRegion = null;
                redrawRegion();
            }
        }

        function confirmOverlaySelection() {
            if (!overlayRegion) return;

            const regionNumber = basketRegions.length + 1;
            const colors = ['#667eea', '#f5576c'];

            const newRegion = {
                x: overlayRegion.x,
                y: overlayRegion.y,
                width: overlayRegion.width,
                height: overlayRegion.height,
                number: regionNumber,
                color: colors[(regionNumber - 1) % colors.length]
            };

            basketRegions.push(newRegion);
            updateRegionDisplay();
            toggleRegionSelection();
        }

        function cancelOverlaySelection() {
            if (isSelectingRegion) {
                toggleRegionSelection();
            }
        }

        function clearLastRegion() {
            if (basketRegions.length > 0) {
                basketRegions.pop();
                updateRegionDisplay();
                showStatus('Last basket region removed.', 'complete');
            }
        }

        function clearAllRegions() {
            basketRegions = [];
            updateRegionDisplay();
            showStatus('All basket regions cleared. Will use full frame detection.', 'complete');
        }

        function updateRegionDisplay() {
            const indicator = document.getElementById('regionIndicator');
            const regionList = document.getElementById('regionList');
            const selectBtn = document.getElementById('selectRegionBtn');

            if (basketRegions.length === 0) {
                regionList.innerHTML = 'None selected';
                indicator.classList.remove('set');
                document.getElementById('clearRegionBtn').style.display = 'none';
                selectBtn.disabled = false;
                selectBtn.textContent = 'üìç Add Basket Region';
            } else {
                const badges = basketRegions.map((r, i) =>
                    `<span class="region-badge" style="background: ${r.color}">Region ${r.number}</span>`
                ).join(' ');
                regionList.innerHTML = badges;
                indicator.classList.add('set');
                document.getElementById('clearRegionBtn').style.display = 'inline-flex';
                selectBtn.disabled = basketRegions.length >= MAX_REGIONS;
                if (basketRegions.length >= MAX_REGIONS) {
                    selectBtn.textContent = 'Max regions reached';
                } else {
                    selectBtn.textContent = 'üìç Add Basket Region';
                }
            }
            
            redrawRegion();
            updateGuidedWorkflow();
        }

        function updateGuidedWorkflow() {
            const processBtn = document.getElementById('processBtn');
            const setupGuide = document.getElementById('setupGuide');
            const nextStepsPanel = document.getElementById('nextStepsPanel');

            if (basketRegions.length === 0) {
                processBtn.style.display = 'block';
                processBtn.innerHTML = '<span>‚ñ∂ Start Detection (Full Frame)</span>';
                if (nextStepsPanel) nextStepsPanel.style.display = 'none';
            } else {
                processBtn.style.display = 'none'; // hide standalone button; next-steps panel takes over
                setupGuide.style.display = 'none';

                if (!nextStepsPanel) {
                    // Create the next-steps panel once
                    const panel = document.createElement('div');
                    panel.id = 'nextStepsPanel';
                    panel.style.cssText = 'margin-top: 15px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 18px; border-radius: 12px; color: white; animation: fadeSlideIn 0.4s ease;';
                    processBtn.parentNode.insertBefore(panel, processBtn);
                }

                const panel = document.getElementById('nextStepsPanel');
                panel.style.display = 'block';

                if (basketRegions.length < MAX_REGIONS) {
                    panel.innerHTML = `
                        <div style="font-weight: 700; font-size: 15px; margin-bottom: 12px;">Basket ${basketRegions.length} selected!</div>
                        <div style="display: flex; gap: 10px;">
                            <button class="btn" onclick="processVideo()" style="flex: 1; background: #4CAF50; color: white; border: none; font-weight: 700; font-size: 15px; padding: 14px;">
                                Start Detection
                            </button>
                            <button class="btn" onclick="startRegionSelection()" style="flex: 1; background: rgba(255,255,255,0.2); color: white; border: 1px solid rgba(255,255,255,0.4); font-size: 14px; padding: 14px;">
                                Add Basket ${basketRegions.length + 1}
                            </button>
                        </div>
                        <div style="font-size: 12px; opacity: 0.8; margin-top: 8px; text-align: center;">Adding both baskets improves accuracy</div>
                    `;
                } else {
                    panel.innerHTML = `
                        <div style="font-weight: 700; font-size: 15px; margin-bottom: 12px;">Both baskets selected!</div>
                        <button class="btn" onclick="processVideo()" style="width: 100%; background: #4CAF50; color: white; border: none; font-weight: 700; font-size: 16px; padding: 16px; animation: pulseGlow 1.5s ease-in-out infinite;">
                            Start Detection
                        </button>
                    `;
                }

                // Scroll the panel into view
                panel.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }

        function startRegionSelection() {
            if (basketRegions.length >= MAX_REGIONS) {
                showStatus(`Maximum ${MAX_REGIONS} basket regions allowed.`, 'complete');
                return;
            }
            toggleRegionSelection();
        }

        // Called when slow processing is detected ‚Äî stops processing,
        // reloads the video to populate the browser cache, then retries.
        let _processingAborted = false;
        let _slowRetryCount = 0;       // How many times we've auto-reloaded for slow processing
        const _MAX_AUTO_RETRIES = 3;   // Auto-reload up to this many times before showing manual button

        function reloadAndRetry() {
            // Abort current processing loop
            _processingAborted = true;
            document.getElementById('processBtn').disabled = false;

            // Remove the slow banner
            const banner = document.getElementById('slowBanner');
            if (banner) banner.remove();

            _slowRetryCount++;
            showStatus(`Reloading video to warm up decoder... (attempt ${_slowRetryCount})`, 'processing');

            const video = document.getElementById('videoPlayer');
            const processingVideo = document.getElementById('processingVideo');

            // Re-set the source to force a fresh load from cache
            const src = video.src;
            video.src = '';
            processingVideo.src = '';

            // Small delay then reload
            setTimeout(() => {
                video.src = src;
                processingVideo.src = src;

                video.onloadedmetadata = () => {
                    // Force first frame render on both
                    video.currentTime = 0.001;
                    processingVideo.currentTime = 0.001;

                    showStatus(`Video reloaded (attempt ${_slowRetryCount}). Starting detection...`, 'complete');
                    // Auto-start processing after a brief moment for decoder to settle
                    setTimeout(() => processVideo(), 500);
                };
            }, 200);
        }

        function skipToProcessing() {
            document.getElementById('setupGuide').style.display = 'none';
            // If no baskets selected yet, show the process button directly
            if (basketRegions.length === 0) {
                document.getElementById('processBtn').style.display = 'block';
                document.getElementById('processBtn').innerHTML = '<span>‚ñ∂ Start Detection (Full Frame)</span>';
            }
            showStatus('You can still add basket regions before processing for better accuracy.', 'complete');
        }

        function redrawRegion() {
            if (!selectionCanvas) return;

            selectionCtx.clearRect(0, 0, selectionCanvas.width, selectionCanvas.height);

            // Manage has-regions class for passive display
            if (basketRegions.length > 0 && !isSelectingRegion) {
                selectionCanvas.classList.add('has-regions');

                // Draw semi-transparent overlay
                selectionCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                selectionCtx.fillRect(0, 0, selectionCanvas.width, selectionCanvas.height);

                // Draw each saved region
                basketRegions.forEach(region => {
                    const x = region.x * selectionCanvas.width;
                    const y = region.y * selectionCanvas.height;
                    const width = region.width * selectionCanvas.width;
                    const height = region.height * selectionCanvas.height;

                    // Clear the region
                    selectionCtx.clearRect(x, y, width, height);

                    // Draw colored border
                    selectionCtx.strokeStyle = region.color;
                    selectionCtx.lineWidth = 3;
                    selectionCtx.strokeRect(x, y, width, height);

                    // Draw label with background ‚Äî position above the box
                    const label = `BASKET ${region.number}`;
                    selectionCtx.font = 'bold 12px sans-serif';
                    const textWidth = selectionCtx.measureText(label).width;
                    const labelY = y > 26 ? y - 26 : y + height + 4;

                    selectionCtx.fillStyle = region.color;
                    selectionCtx.fillRect(x, labelY, textWidth + 10, 22);

                    selectionCtx.fillStyle = 'white';
                    selectionCtx.fillText(label, x + 5, labelY + 15);
                });
            } else if (!isSelectingRegion) {
                selectionCanvas.classList.remove('has-regions');
            }
        }

        function drawMotionChart() {
            const container = document.getElementById('motionChartContainer');
            const canvas = document.getElementById('motionChart');
            if (!canvas || chartData.length === 0) return;

            // Ensure container is visible before measuring
            if (container.style.display === 'none') {
                container.style.display = 'block';
            }

            // Size canvas to match CSS layout (avoids blurry rendering)
            const cssW = canvas.clientWidth;
            const cssH = canvas.clientHeight;
            if (cssW === 0 || cssH === 0) return; // not laid out yet
            canvas.width = cssW * 2;
            canvas.height = cssH * 2;
            const ctx = canvas.getContext('2d');
            ctx.scale(2, 2);

            const W = cssW;
            const H = cssH;
            const pad = { top: 8, bottom: 18, left: 30, right: 8 };
            const plotW = W - pad.left - pad.right;
            const plotH = H - pad.top - pad.bottom;
            const duration = document.getElementById('processingVideo').duration || 1;

            // Background
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, W, H);

            // Collect all motion and threshold values across all regions
            const regionCount = chartData.length > 0 ? chartData[0].motions.length : 1;
            const allValues = [];
            chartData.forEach(d => {
                d.motions.forEach(m => allValues.push(m));
                d.thresholds.forEach(t => allValues.push(t));
            });

            // Cap y-axis at 95th percentile for readability
            allValues.sort((a, b) => a - b);
            const p95 = allValues[Math.floor(allValues.length * 0.95)] || 10;
            const maxY = Math.max(10, p95 * 1.2);

            // Grid lines
            ctx.strokeStyle = 'rgba(255,255,255,0.08)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = pad.top + (plotH / 4) * i;
                ctx.beginPath();
                ctx.moveTo(pad.left, y);
                ctx.lineTo(W - pad.right, y);
                ctx.stroke();
            }

            // Y-axis labels
            ctx.fillStyle = '#666';
            ctx.font = '9px sans-serif';
            ctx.textAlign = 'right';
            for (let i = 0; i <= 4; i++) {
                const y = pad.top + (plotH / 4) * i;
                const val = Math.round(maxY * (1 - i / 4));
                ctx.fillText(val, pad.left - 3, y + 3);
            }

            // X-axis time labels
            ctx.textAlign = 'center';
            const timeSteps = Math.max(1, Math.min(6, Math.ceil(duration / 30)));
            for (let i = 0; i <= timeSteps; i++) {
                const t = (duration / timeSteps) * i;
                const x = pad.left + (t / duration) * plotW;
                ctx.fillText(formatTime(t), x, H - 2);
            }

            // Detection markers (green vertical bars)
            chartDetections.forEach(t => {
                const x = pad.left + (t / duration) * plotW;
                ctx.fillStyle = 'rgba(76, 175, 80, 0.25)';
                ctx.fillRect(x - 3, pad.top, 6, plotH);
                ctx.fillStyle = '#4CAF50';
                ctx.beginPath();
                ctx.arc(x, pad.top + 4, 3, 0, Math.PI * 2);
                ctx.fill();
            });

            // Line drawing helper ‚Äî clamps values at maxY
            function line(color, lw, dash, fn) {
                ctx.strokeStyle = color;
                ctx.lineWidth = lw;
                if (dash) ctx.setLineDash(dash);
                ctx.beginPath();
                chartData.forEach((d, i) => {
                    const x = pad.left + (d.time / duration) * plotW;
                    const y = pad.top + plotH * (1 - Math.min(1, fn(d) / maxY));
                    i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
                });
                ctx.stroke();
                if (dash) ctx.setLineDash([]);
            }

            // Colors per region
            const motionColors = ['#4fc3f7', '#ce93d8'];
            const threshColors = ['rgba(255, 82, 82, 0.6)', 'rgba(255, 167, 38, 0.6)'];

            // Draw per-region threshold and motion lines
            for (let r = 0; r < regionCount; r++) {
                line(threshColors[r % threshColors.length], 1, [3, 3], d => d.thresholds[r]);
                line(motionColors[r % motionColors.length], 1.5, null, d => d.motions[r]);
            }
        }

        async function processVideo() {
            const video = document.getElementById('processingVideo'); // Use hidden video
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = 320;
            canvas.height = 180;
            
            highlights = [];
            chartData = [];
            chartDetections = [];

            // Update legend for number of regions
            const legendEl = document.getElementById('motionChartLegend');
            if (basketRegions.length >= 2) {
                legendEl.innerHTML =
                    '<span><span class="dot" style="background: #4fc3f7;"></span> Basket 1</span>' +
                    '<span><span class="dot" style="background: #ce93d8;"></span> Basket 2</span>' +
                    '<span><span class="dot" style="background: rgba(255,82,82,0.6);"></span> Threshold</span>' +
                    '<span><span class="dot" style="background: #4CAF50;"></span> Detection</span>';
            } else {
                legendEl.innerHTML =
                    '<span><span class="dot" style="background: #4fc3f7;"></span> Motion</span>' +
                    '<span><span class="dot" style="background: rgba(255,82,82,0.6);"></span> Threshold</span>' +
                    '<span><span class="dot" style="background: #4CAF50;"></span> Detection</span>';
            }

            document.getElementById('processBtn').disabled = true;
            const nsp = document.getElementById('nextStepsPanel');
            if (nsp) nsp.style.display = 'none';
            document.getElementById('progressContainer').style.display = 'block';
            document.getElementById('highlightsSection').style.display = 'block';
            document.getElementById('motionChartContainer').style.display = 'block';

            const regionMsg = basketRegions.length > 0
                ? ` Detecting motion in ${basketRegions.length} region(s).`
                : ' Using full-frame motion detection.';
            showStatus('Processing video...' + regionMsg, 'processing');

            // Warm up the video decoder before processing ‚Äî this ensures the browser
            // has fully buffered the video data and parsed the keyframe index.
            // Without this, mobile browsers often seek extremely slowly on first load
            // (black preview = data not ready), but fast on second load (cached).
            await warmUpVideo(video, 'Processing video...' + regionMsg);

            const duration = video.duration;
            const fps = 3;
            const interval = 1 / fps;

            let previousFrame = null;
            let framesProcessed = 0;
            const regionCount = Math.max(1, basketRegions.length);

            // Per-region motion histories
            let motionHistories = [];
            for (let i = 0; i < regionCount; i++) motionHistories.push([]);

            // Reset EMA state
            initRegionEMAs();

            // Performance diagnostics
            resetPerfStats();
            perfStats.startTime = performance.now();
            await probeVideoInfo(video);
            _processingAborted = false;

            for (let time = 0; time < duration; time += interval) {
                if (_processingAborted) return; // Abort if user triggered reload
                const frameStart = performance.now();

                // --- Timed seek ---
                const seekStart = performance.now();
                video.currentTime = time;

                let seekTimedOut = false;
                await new Promise(resolve => {
                    let resolved = false;
                    const done = (timedOut) => { if (!resolved) { resolved = true; if (timedOut) seekTimedOut = true; resolve(); } };
                    const timeout = setTimeout(() => done(true), 5000);
                    video.addEventListener('seeked', () => { clearTimeout(timeout); done(false); }, { once: true });
                });
                const seekMs = performance.now() - seekStart;
                perfStats.seekTimes.push(seekMs);
                if (seekTimedOut) perfStats.seekTimeouts++;
                perfStats.lastSeeks.push(seekMs);
                if (perfStats.lastSeeks.length > 10) perfStats.lastSeeks.shift();

                // --- Timed draw + getImageData ---
                const drawStart = performance.now();
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                let currentFrame;
                try {
                    currentFrame = ctx.getImageData(0, 0, canvas.width, canvas.height);
                } catch (e) {
                    // Tainted canvas ‚Äî cross-origin video blocks pixel reading
                    document.getElementById('processBtn').disabled = false;
                    document.getElementById('progressContainer').style.display = 'none';
                    showStatus('Cannot process this video due to cross-origin restrictions. The video server does not allow pixel-level access from the browser. Please download the video and upload it as a local file instead.', 'error');
                    return;
                }
                perfStats.drawTimes.push(performance.now() - drawStart);

                if (previousFrame) {
                    // --- Timed motion detection ---
                    const motionStart = performance.now();
                    const motions = detectMotion(previousFrame, currentFrame);
                    perfStats.motionTimes.push(performance.now() - motionStart);

                    // Push each region's motion into its own history
                    motions.forEach((m, i) => {
                        motionHistories[i].push(m);
                        if (motionHistories[i].length > 15) motionHistories[i].shift();
                    });

                    // Record for chart: store per-region motions and thresholds
                    const thresholds = motions.map((_, i) => getRegionThreshold(i));
                    chartData.push({ time, motions, thresholds, detected: false });

                    // Detect potential basket (need at least 4 frames per region)
                    const minHistory = Math.min(...motionHistories.map(h => h.length));
                    if (minHistory >= 4) {
                        const detectionResult = calculateBasketScore(motionHistories, time);
                        
                        if (detectionResult.passes) {
                            const lastHighlight = highlights[highlights.length - 1];
                            if (!lastHighlight || time - lastHighlight.timestamp > settings.minGap) {
                                // Mark on chart
                                chartDetections.push(time);
                                if (chartData.length > 0) chartData[chartData.length - 1].detected = true;

                                // Capture thumbnail with detection data
                                const thumbnail = captureThumbnail(video, canvas, ctx, {
                                    motion: detectionResult.motion,
                                    rim: detectionResult.rim,
                                    ball: detectionResult.ball,
                                    score: detectionResult.score,
                                    regionIndex: detectionResult.regionIndex
                                });
                                
                                highlights.push({
                                    timestamp: time,
                                    confidence: Math.min(100, detectionResult.score),
                                    thumbnail: thumbnail,
                                    enabled: true,
                                    reasons: detectionResult.reasons,
                                    debugData: {
                                        motion: detectionResult.motion,
                                        rim: detectionResult.rim,
                                        ball: detectionResult.ball,
                                        motionDrop: detectionResult.motionDrop,
                                        rimVisible: detectionResult.rimVisible,
                                        ballPresent: detectionResult.ballPresent
                                    }
                                });
                                
                                // Update UI in real-time
                                updateHighlightsDisplay();
                                document.getElementById('basketsFound').textContent = highlights.length;
                                
                                // Start playing clips as soon as we get the first one
                                if (highlights.length === 1 && !isPlayingAll) {
                                    // Hide the setup guide
                                    document.getElementById('setupGuide').style.display = 'none';
                                    
                                    // Start playing immediately
                                    setTimeout(() => {
                                        playAllHighlights();
                                    }, 500); // Small delay to let UI update
                                }
                            }
                        }
                    }
                }
                
                previousFrame = currentFrame;
                framesProcessed++;
                perfStats.frameCount = framesProcessed;
                perfStats.frameTimes.push(performance.now() - frameStart);

                const progress = Math.floor((time / duration) * 100);
                document.getElementById('progressFill').style.width = progress + '%';
                document.getElementById('progressText').textContent = progress + '%';
                document.getElementById('framesAnalyzed').textContent = framesProcessed;
                document.getElementById('currentProcessTime').textContent = formatTime(time);

                // Slow-processing detection: after 2 frames, check if we're crawling
                if (framesProcessed === 2 && !document.getElementById('slowBanner')) {
                    const avgFrame = perfStats.frameTimes.reduce((a, b) => a + b, 0) / perfStats.frameTimes.length;
                    if (avgFrame > 1500) {
                        if (_slowRetryCount < _MAX_AUTO_RETRIES) {
                            // Auto-reload silently for the first 3 attempts
                            console.log(`[Perf] Slow processing detected (avg ${(avgFrame / 1000).toFixed(1)}s/frame). Auto-reloading (attempt ${_slowRetryCount + 1}/${_MAX_AUTO_RETRIES})...`);
                            reloadAndRetry();
                            return; // exit processVideo ‚Äî reloadAndRetry will restart it
                        } else {
                            // 4th time still slow ‚Äî show manual button
                            const totalFrames = Math.ceil(duration / interval);
                            const estMinutes = ((totalFrames * avgFrame) / 60000).toFixed(0);
                            const banner = document.createElement('div');
                            banner.id = 'slowBanner';
                            banner.className = 'slow-processing-banner';
                            banner.innerHTML = `
                                <p><strong>Slow processing detected</strong><br>
                                Avg ${(avgFrame / 1000).toFixed(1)}s per frame ‚Äî at this rate it would take ~${estMinutes} min.<br>
                                Auto-reload didn't help after ${_MAX_AUTO_RETRIES} attempts. You can try once more or wait it out.</p>
                                <button onclick="reloadAndRetry()">Reload Video & Retry</button>
                            `;
                            document.getElementById('progressContainer').appendChild(banner);
                        }
                    } else if (_slowRetryCount > 0) {
                        // Was slow before but now it's fast ‚Äî the reload worked!
                        console.log(`[Perf] Processing speed OK after ${_slowRetryCount} reload(s) (avg ${avgFrame.toFixed(0)}ms/frame).`);
                    }
                }

                // Allow UI to update and redraw chart every 15 frames
                if (framesProcessed % 15 === 0) {
                    drawMotionChart();
                    updatePerfUI();
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }
            
            // Final perf update & console summary
            updatePerfUI();
            if (perfStats) {
                const s = perfStats;
                const elapsed = ((performance.now() - s.startTime) / 1000).toFixed(1);
                const avg = arr => arr.length ? (arr.reduce((a, b) => a + b, 0) / arr.length).toFixed(1) : '‚Äî';
                console.log(`%c[Perf Summary]`, 'color: #64ffda; font-weight: bold;',
                    `\n  Frames: ${s.frameCount} in ${elapsed}s (${(s.frameCount / elapsed).toFixed(2)} eff. FPS)` +
                    `\n  Seek ‚Äî avg: ${avg(s.seekTimes)}ms, min: ${Math.min(...s.seekTimes).toFixed(0)}ms, max: ${Math.max(...s.seekTimes).toFixed(0)}ms` +
                    `\n  Seek timeouts: ${s.seekTimeouts}, slow (>500ms): ${s.seekTimes.filter(t => t > 500).length}` +
                    `\n  Draw+read avg: ${avg(s.drawTimes)}ms, Motion calc avg: ${avg(s.motionTimes)}ms` +
                    `\n  Total/frame avg: ${avg(s.frameTimes)}ms` +
                    `\n  Codec: ${document.getElementById('perfCodec').textContent}` +
                    `\n  Resolution: ${document.getElementById('perfResolution').textContent}`
                );
            }

            document.getElementById('processBtn').disabled = false;
            document.getElementById('progressContainer').style.display = 'none';
            document.getElementById('setupGuide').style.display = 'none';
            drawMotionChart();

            video.currentTime = 0;
            updateHighlightsDisplay();
            
            // Only auto-start if not already playing (might have started on first clip)
            if (highlights.length > 0 && !isPlayingAll) {
                showStatus(`Processing complete! Found ${highlights.length} clip(s). Playing now...`, 'complete');
                setTimeout(() => {
                    playAllHighlights();
                }, 1000);
            } else if (isPlayingAll) {
                showStatus(`Processing complete! Found ${highlights.length} clip(s) total.`, 'complete');
            } else {
                showStatus(`Processing complete! No clips detected.`, 'complete');
            }
        }

        // Returns array of per-region motion values, or [fullFrameMotion] if no regions
        function detectMotion(frame1, frame2) {
            const data1 = frame1.data;
            const data2 = frame2.data;
            const width = frame1.width;
            const height = frame1.height;

            if (basketRegions.length > 0) {
                return basketRegions.map(region => {
                    const startX = Math.floor(region.x * width);
                    const startY = Math.floor(region.y * height);
                    const endX = Math.floor((region.x + region.width) * width);
                    const endY = Math.floor((region.y + region.height) * height);

                    let regionDiff = 0;
                    let regionCount = 0;

                    for (let y = startY; y < endY; y += 2) {
                        for (let x = startX; x < endX; x += 2) {
                            const idx = (y * width + x) * 4;
                            const r = Math.abs(data1[idx] - data2[idx]);
                            const g = Math.abs(data1[idx + 1] - data2[idx + 1]);
                            const b = Math.abs(data1[idx + 2] - data2[idx + 2]);
                            regionDiff += (r + g + b) / 3;
                            regionCount++;
                        }
                    }

                    return regionCount > 0 ? regionDiff / regionCount : 0;
                });
            } else {
                let diff = 0;
                let count = 0;
                for (let i = 0; i < data1.length; i += 40) {
                    const r = Math.abs(data1[i] - data2[i]);
                    const g = Math.abs(data1[i + 1] - data2[i + 1]);
                    const b = Math.abs(data1[i + 2] - data2[i + 2]);
                    diff += (r + g + b) / 3;
                    count++;
                }
                return [diff / count];
            }
        }

        function initRegionEMAs() {
            const count = Math.max(1, basketRegions.length);
            regionEMAs = [];
            for (let i = 0; i < count; i++) {
                regionEMAs.push({ mean: 0, variance: 0, initialized: false });
            }
        }

        function updateRegionEMA(regionIdx, motion) {
            const ema = regionEMAs[regionIdx];
            if (!ema.initialized) {
                ema.mean = motion;
                ema.variance = 0;
                ema.initialized = true;
                return;
            }
            const diff = motion - ema.mean;
            ema.mean += EMA_ALPHA * diff;
            ema.variance = (1 - EMA_ALPHA) * (ema.variance + EMA_ALPHA * diff * diff);
        }

        function getScaledMinThreshold(regionIdx) {
            if (basketRegions.length === 0 || regionIdx >= basketRegions.length) return MIN_THRESHOLD;
            const region = basketRegions[regionIdx];
            const regionArea = region.width * region.height;
            const referenceArea = 0.01; // 10% √ó 10% ‚Äî small hoop-sized region
            if (regionArea <= referenceArea) return MIN_THRESHOLD;
            const scale = Math.sqrt(referenceArea / regionArea);
            return Math.max(0.3, MIN_THRESHOLD * scale);
        }

        function getRegionThreshold(regionIdx) {
            const ema = regionEMAs[regionIdx];
            const minT = getScaledMinThreshold(regionIdx);
            if (!ema || !ema.initialized) return minT;
            const stdDev = Math.sqrt(Math.max(0, ema.variance));
            return Math.max(minT, ema.mean + ANOMALY_K * stdDev);
        }

        // motionHistories: array of arrays, one per region
        // Each inner array is the last N motion values for that region
        function calculateBasketScore(motionHistories, time) {
            let bestScore = 0;
            let bestReasons = [];
            let bestMotion = 0;
            let bestThreshold = getScaledMinThreshold(0);
            let bestRegionIdx = 0;

            motionHistories.forEach((history, rIdx) => {
                const currentMotion = history[history.length - 1];
                const threshold = getRegionThreshold(rIdx);
                const ceiling = threshold * CEILING_K;

                const isAnomaly = currentMotion > threshold;
                const isTooBig = currentMotion > ceiling;

                // Brief burst check in last 4 frames
                const recentAbove = history.slice(-4).filter(m => m > threshold).length;
                const isBrief = recentAbove >= 1 && recentAbove <= 2;
                const isSustained = recentAbove >= 3;

                let score = 0;
                let reasons = [];

                if (isTooBig) {
                    // Motion too large ‚Äî likely a person, not a ball
                    score = 0;
                    reasons.push('(too large)');
                } else if (isAnomaly && isBrief) {
                    score += 70;
                    reasons.push('Anomaly Burst');
                } else if (isAnomaly && !isSustained) {
                    score += 40;
                    reasons.push('Anomaly');
                }

                // Spike/drop pattern bonus
                const avgRecent = history.slice(-2).reduce((a, b) => a + b) / 2;
                const earlier = history.slice(-5, -2);
                const avgEarlier = earlier.length > 0 ? earlier.reduce((a, b) => a + b) / earlier.length : 0;
                if (avgRecent > avgEarlier * 2 && avgRecent > threshold * 0.8 && !isTooBig) {
                    score += 20;
                    reasons.push('Sharp Spike');
                }

                if (isSustained) {
                    score = Math.max(0, score - 50);
                    reasons.push('(sustained)');
                }

                // Update EMA AFTER scoring
                updateRegionEMA(rIdx, currentMotion);

                if (score > bestScore) {
                    bestScore = score;
                    bestReasons = reasons;
                    bestMotion = currentMotion;
                    bestThreshold = threshold;
                    bestRegionIdx = rIdx;
                }
            });

            return {
                score: bestScore, motion: bestMotion, rim: 0, ball: 0,
                threshold: bestThreshold, regionIndex: bestRegionIdx,
                motionDrop: false, rimVisible: false, ballPresent: false,
                reasons: bestReasons,
                passes: bestScore >= 50
            };
        }

        function captureThumbnail(video, canvas, ctx, detectionData) {
            // Capture full video frame as thumbnail
            const thumbCanvas = document.createElement('canvas');
            thumbCanvas.width = 320;
            thumbCanvas.height = 180;
            const thumbCtx = thumbCanvas.getContext('2d');
            thumbCtx.drawImage(video, 0, 0, 320, 180);

            return thumbCanvas.toDataURL('image/jpeg', 0.8);
        }

        function getEnabledHighlights() {
            return highlights.filter(h => h.enabled !== false);
        }

        function toggleHighlight(index, event) {
            event.stopPropagation();
            highlights[index].enabled = !highlights[index].enabled;
            updateHighlightsDisplay();
        }

        function updateHighlightsDisplay() {
            const section = document.getElementById('highlightsSection');
            const list = document.getElementById('highlightsList');
            const count = document.getElementById('highlightCount');

            if (highlights.length === 0) {
                section.style.display = 'none';
                return;
            }

            section.style.display = 'block';
            const enabledCount = getEnabledHighlights().length;
            count.textContent = enabledCount + ' of ' + highlights.length + (highlights.length === 1 ? ' basket' : ' baskets');

            const canShare = !!navigator.share;
            const shareBtn = document.getElementById('shareBtn');
            if (shareBtn) shareBtn.style.display = canShare ? 'inline-flex' : 'none';

            list.innerHTML = highlights.map((h, i) => {
                const reasons = h.reasons ? h.reasons.join(', ') : 'Unknown';
                const debugData = h.debugData || {};
                const isEnabled = h.enabled !== false;
                const disabledClass = isEnabled ? '' : ' disabled';

                return `
                <div class="highlight-item${disabledClass}" onclick="jumpToHighlight(${h.timestamp})" title="Click to play">
                    ${h.thumbnail ? `
                        <div class="highlight-thumbnail">
                            <img src="${h.thumbnail}" alt="Basket at ${formatTime(h.timestamp)}">
                            <div class="play-icon">‚ñ∂</div>
                        </div>
                    ` : ''}
                    <div class="highlight-number">${i + 1}</div>
                    <div class="highlight-info">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div class="highlight-time">${formatTime(h.timestamp)}</div>
                            <label class="highlight-toggle" onclick="event.stopPropagation()">
                                <input type="checkbox" ${isEnabled ? 'checked' : ''} onchange="toggleHighlight(${i}, event)">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                        <div>
                            <span class="confidence">Score: ${Math.round(h.confidence)}</span>
                        </div>
                        <div style="font-size: 10px; color: #667eea; margin-top: 4px;">
                            ${reasons}
                        </div>
                        ${debugData.motion !== undefined ? `
                        <div style="font-size: 9px; color: #999; margin-top: 4px; font-family: monospace;">
                            M:${debugData.motion.toFixed(1)}
                            R:${debugData.rim.toFixed(1)}
                            B:${debugData.ball.toFixed(1)}
                            ${debugData.motionDrop ? 'üìâ' : ''}
                            ${debugData.rimVisible ? 'üéØ' : ''}
                            ${debugData.ballPresent ? 'üèÄ' : ''}
                        </div>
                        ` : ''}
                        <div class="highlight-actions" onclick="event.stopPropagation()">
                            <button onclick="exportSingleClip(${i})" title="Export this clip">üé¨ Clip</button>
                            ${canShare ? `<button onclick="shareSingleHighlight(${i})" title="Share this highlight">üì§ Share</button>` : ''}
                        </div>
                    </div>
                </div>
            `}).join('');

            // Show Play All button when highlights are available
            const playAllBtn = document.getElementById('playAllBtn');
            if (playAllBtn) {
                playAllBtn.style.display = enabledCount > 0 ? 'block' : 'none';
            }

            // Enable playback controls when highlights are available
            enablePlaybackControls();
        }

        function jumpToHighlight(timestamp) {
            const video = document.getElementById('videoPlayer');
            const startTime = Math.max(0, timestamp - 3); // Start 3 seconds before
            const endTime = timestamp + 1; // Stop 1 second after
            
            video.currentTime = startTime;
            video.play();
            
            // Set up listener to stop at end time
            const stopListener = () => {
                if (video.currentTime >= endTime) {
                    video.pause();
                    video.removeEventListener('timeupdate', stopListener);
                }
            };
            
            video.addEventListener('timeupdate', stopListener);
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            const ms = Math.floor((seconds % 1) * 10);
            return `${mins}:${secs.toString().padStart(2, '0')}.${ms}`;
        }

        function exportTimestamps() {
            const enabled = getEnabledHighlights();
            const text = enabled.map((h, i) =>
                `${i + 1}. ${formatTime(h.timestamp)} (${Math.round(h.confidence)}% confidence)`
            ).join('\n');

            navigator.clipboard.writeText(text).then(() => {
                showStatus(`${enabled.length} timestamp(s) copied to clipboard!`, 'complete');
            });
        }

        function exportJSON() {
            const enabled = getEnabledHighlights();
            const data = {
                videoSource: currentTab === 'file' ? 'local file' : document.getElementById('videoUrl').value,
                processedDate: new Date().toISOString(),
                totalHighlights: enabled.length,
                highlights: enabled.map((h, i) => ({
                    number: i + 1,
                    timestamp: h.timestamp,
                    formattedTime: formatTime(h.timestamp),
                    confidence: Math.round(h.confidence)
                }))
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `basketball-highlights-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function playPreviousClip() {
            const prev = findPrevEnabledIndex(currentHighlightIndex - 1);
            if (prev >= 0) {
                currentHighlightIndex = prev;
                playNextHighlight();
            }
        }

        function playNextClip() {
            let next = findNextEnabledIndex(currentHighlightIndex + 1);
            if (next < 0) {
                // Loop back to start
                next = findNextEnabledIndex(0);
            }
            if (next >= 0) {
                currentHighlightIndex = next;
                playNextHighlight();
            }
        }

        function playAllHighlights() {
            const enabled = getEnabledHighlights();
            if (enabled.length === 0) return;

            isPlayingAll = true;
            currentHighlightIndex = 0;

            // Skip to first enabled highlight
            while (currentHighlightIndex < highlights.length && highlights[currentHighlightIndex].enabled === false) {
                currentHighlightIndex++;
            }

            playNextHighlight();
        }

        function findNextEnabledIndex(fromIndex) {
            for (let i = fromIndex; i < highlights.length; i++) {
                if (highlights[i].enabled !== false) return i;
            }
            return -1;
        }

        function findPrevEnabledIndex(fromIndex) {
            for (let i = fromIndex; i >= 0; i--) {
                if (highlights[i].enabled !== false) return i;
            }
            return -1;
        }

        function playNextHighlight() {
            // Skip disabled highlights
            if (isPlayingAll && currentHighlightIndex < highlights.length && highlights[currentHighlightIndex].enabled === false) {
                currentHighlightIndex = findNextEnabledIndex(currentHighlightIndex);
            }

            if (!isPlayingAll || currentHighlightIndex < 0 || currentHighlightIndex >= highlights.length) {
                stopPlayingAll();
                return;
            }

            const highlight = highlights[currentHighlightIndex];
            const video = document.getElementById('videoPlayer');
            const enabledList = getEnabledHighlights();
            const enabledIdx = enabledList.indexOf(highlight);

            // Show overlay
            const overlay = document.getElementById('videoOverlay');
            overlay.style.display = 'block';
            document.getElementById('overlayClipNumber').textContent = enabledIdx + 1;
            document.getElementById('overlayTotalClips').textContent = enabledList.length;
            document.getElementById('overlayTimestamp').textContent = formatTime(highlight.timestamp);

            // Highlight the current item in the list
            document.querySelectorAll('.highlight-item').forEach((item, idx) => {
                item.classList.toggle('playing', idx === currentHighlightIndex);
            });

            // Scroll to current highlight in theater mode WITHOUT focus jump
            if (isTheaterMode) {
                const currentItem = document.querySelectorAll('.highlight-item')[currentHighlightIndex];
                if (currentItem) {
                    const container = document.getElementById('highlightsList');
                    const itemRect = currentItem.getBoundingClientRect();
                    const containerRect = container.getBoundingClientRect();

                    // Calculate scroll position to center the item
                    const scrollLeft = currentItem.offsetLeft - (containerRect.width / 2) + (itemRect.width / 2);
                    container.scrollLeft = scrollLeft;
                }
            }

            const startTime = Math.max(0, highlight.timestamp - 3);
            const endTime = highlight.timestamp + 1;
            const clipDuration = endTime - startTime;

            document.getElementById('overlayClipDuration').textContent = clipDuration.toFixed(1) + 's';

            video.currentTime = startTime;
            video.play();

            // Remove any existing listener
            if (playAllListener) {
                video.removeEventListener('timeupdate', playAllListener);
            }

            // Set up listener to move to next highlight and update progress
            playAllListener = () => {
                const elapsed = video.currentTime - startTime;
                const progress = Math.min(100, (elapsed / clipDuration) * 100);

                // Update overlay progress
                document.getElementById('overlayProgress').style.width = progress + '%';
                document.getElementById('overlayClipTime').textContent = elapsed.toFixed(1) + 's';

                if (video.currentTime >= endTime) {
                    video.removeEventListener('timeupdate', playAllListener);
                    // Find next enabled highlight
                    currentHighlightIndex = findNextEnabledIndex(currentHighlightIndex + 1);

                    // Small pause between highlights
                    setTimeout(() => {
                        if (isPlayingAll) {
                            playNextHighlight();
                        }
                    }, 300);
                }
            };

            video.addEventListener('timeupdate', playAllListener);
        }

        function stopPlayingAll() {
            isPlayingAll = false;
            const video = document.getElementById('videoPlayer');
            
            if (playAllListener) {
                video.removeEventListener('timeupdate', playAllListener);
                playAllListener = null;
            }
            
            video.pause();
            
            // Hide overlay
            document.getElementById('videoOverlay').style.display = 'none';
            
            // Remove playing class from all items
            document.querySelectorAll('.highlight-item').forEach(item => {
                item.classList.remove('playing');
            });
        }

        function enablePlaybackControls() {
            // No longer needed - removed mode buttons
        }

        function setupKeyboardNavigation() {
            document.addEventListener('keydown', (e) => {
                // Only handle if we have highlights and not typing in an input
                if (highlights.length === 0 || e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                    return;
                }
                
                const video = document.getElementById('videoPlayer');
                
                switch(e.key) {
                    case 'ArrowRight':
                        e.preventDefault();
                        playNextClip();
                        break;
                        
                    case 'ArrowLeft':
                        e.preventDefault();
                        playPreviousClip();
                        break;
                        
                    case ' ':
                        e.preventDefault();
                        if (video.paused) {
                            if (!isPlayingAll && highlights.length > 0) {
                                playAllHighlights();
                            } else {
                                video.play();
                            }
                        } else {
                            video.pause();
                        }
                        break;
                }
            });
        }

        function showStatus(message, type) {
            const statusEl = document.getElementById('statusMessage');
            statusEl.textContent = message;
            statusEl.className = 'status ' + (type || '');
            statusEl.style.display = 'flex';
        }

        // ‚îÄ‚îÄ‚îÄ FFmpeg WASM Integration ‚îÄ‚îÄ‚îÄ

        // Custom toBlobURL ‚Äî replaces @ffmpeg/util (whose 0.12.2 UMD build is broken)
        async function toBlobURL(url, mimeType) {
            const response = await fetch(url);
            if (!response.ok) throw new Error(`Fetch failed: ${url} (${response.status})`);
            const buf = await response.arrayBuffer();
            return URL.createObjectURL(new Blob([buf], { type: mimeType }));
        }

        async function loadFFmpeg() {
            if (ffmpegLoaded) return true;
            if (ffmpegLoading) return false;
            ffmpegLoading = true;

            const overlay = document.getElementById('ffmpegLoading');
            const titleEl = document.getElementById('ffmpegLoadingTitle');
            const textEl = document.getElementById('ffmpegLoadingText');
            const progressEl = document.getElementById('ffmpegProgressFill');

            overlay.classList.add('active');
            titleEl.textContent = 'Loading Video Editor...';
            textEl.textContent = 'Downloading FFmpeg (~30 MB, first time only)';
            progressEl.style.width = '10%';

            try {
                // Load only @ffmpeg/ffmpeg UMD script (global: FFmpegWASM)
                // Note: @ffmpeg/util@0.12.2 UMD is broken (gh #848), so we use our own toBlobURL
                await loadScript('https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.15/dist/umd/ffmpeg.js')
                    .catch(() => loadScript('https://unpkg.com/@ffmpeg/ffmpeg@0.12.15/dist/umd/ffmpeg.js'));
                progressEl.style.width = '15%';

                textEl.textContent = 'Downloading FFmpeg core...';

                const { FFmpeg } = FFmpegWASM;
                ffmpegInstance = new FFmpeg();

                ffmpegInstance.on('progress', ({ progress }) => {
                    const pct = Math.round(Math.max(0, Math.min(100, progress * 100)));
                    progressEl.style.width = pct + '%';
                    textEl.textContent = `Processing: ${pct}%`;
                });

                const coreBase = 'https://unpkg.com/@ffmpeg/core@0.12.10/dist/umd';
                const ffmpegBase = 'https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.15/dist/umd';

                // Convert all resources to same-origin blob URLs.
                // This is critical: Workers cannot be created from cross-origin URLs,
                // and the ffmpeg class internally spawns a Worker from 814.ffmpeg.js.
                //
                // NOTE: We must NOT pass classWorkerURL to ffmpegInstance.load() because
                // the UMD build forces {type:"module"} when classWorkerURL is set, but the
                // UMD worker (814.ffmpeg.js) uses importScripts() which is only available
                // in classic workers. Instead, we temporarily patch the Worker constructor
                // to intercept the cross-origin worker URL and swap in our blob URL while
                // keeping the worker type as classic.
                const [coreURL, wasmURL, workerBlobURL] = await Promise.all([
                    toBlobURL(`${coreBase}/ffmpeg-core.js`, 'text/javascript'),
                    toBlobURL(`${coreBase}/ffmpeg-core.wasm`, 'application/wasm'),
                    toBlobURL(`${ffmpegBase}/814.ffmpeg.js`, 'text/javascript'),
                ]);
                progressEl.style.width = '80%';

                textEl.textContent = 'Initializing FFmpeg...';

                // Patch Worker to redirect the cross-origin 814.ffmpeg.js to our blob URL
                const OriginalWorker = window.Worker;
                window.Worker = class extends OriginalWorker {
                    constructor(scriptURL, options) {
                        const url = scriptURL instanceof URL ? scriptURL.href : String(scriptURL);
                        if (url.includes('ffmpeg')) {
                            super(workerBlobURL, options);
                        } else {
                            super(scriptURL, options);
                        }
                    }
                };
                try {
                    await ffmpegInstance.load({ coreURL, wasmURL });
                } finally {
                    window.Worker = OriginalWorker;
                }
                progressEl.style.width = '100%';

                ffmpegLoaded = true;
                ffmpegLoading = false;
                overlay.classList.remove('active');
                return true;
            } catch (err) {
                console.error('FFmpeg load error:', err);
                ffmpegLoading = false;
                overlay.classList.remove('active');
                showStatus('Failed to load FFmpeg: ' + (err.message || err), 'error');
                return false;
            }
        }

        function loadScript(src) {
            return new Promise((resolve, reject) => {
                // Skip if already loaded
                if (document.querySelector(`script[src="${src}"]`)) {
                    resolve();
                    return;
                }
                const s = document.createElement('script');
                s.src = src;
                s.onload = resolve;
                s.onerror = reject;
                document.head.appendChild(s);
            });
        }

        async function getVideoData() {
            // Return a fresh ArrayBuffer each time ‚Äî avoids keeping the entire
            // video permanently in JS heap memory, which caused browser crashes
            // on large files.  File.arrayBuffer() re-reads from the OS file
            // reference so the cost is minimal.
            if (currentTab === 'file' && videoFile) {
                return await videoFile.arrayBuffer();
            } else {
                // For URL-based videos, try to fetch
                const video = document.getElementById('videoPlayer');
                try {
                    const response = await fetch(video.src);
                    return await response.arrayBuffer();
                } catch (err) {
                    showStatus('Cannot access video data for clipping. Try uploading the video as a local file.', 'error');
                    return null;
                }
            }
        }

        function guessVideoExtension() {
            if (videoFile && videoFile.name) {
                const ext = videoFile.name.split('.').pop().toLowerCase();
                if (['mp4', 'webm', 'mkv', 'mov', 'avi'].includes(ext)) return ext;
            }
            return 'mp4';
        }

        async function extractClip(highlight) {
            let data = await getVideoData();
            if (!data) return null;

            const ext = guessVideoExtension();
            const inputName = `input.${ext}`;
            const outputName = `clip.${ext}`;

            const startTime = Math.max(0, highlight.timestamp - 3);
            const duration = 4; // 3 seconds before + 1 second after

            const overlay = document.getElementById('ffmpegLoading');
            const titleEl = document.getElementById('ffmpegLoadingTitle');
            const textEl = document.getElementById('ffmpegLoadingText');
            const progressEl = document.getElementById('ffmpegProgressFill');
            overlay.classList.add('active');
            titleEl.textContent = 'Extracting Clip...';
            textEl.textContent = 'Writing video data...';
            progressEl.style.width = '10%';

            try {
                await ffmpegInstance.writeFile(inputName, new Uint8Array(data));
                data = null; // release JS-heap copy so GC can reclaim it
                progressEl.style.width = '30%';
                textEl.textContent = 'Trimming clip...';

                await ffmpegInstance.exec([
                    '-ss', startTime.toFixed(2),
                    '-i', inputName,
                    '-t', duration.toFixed(2),
                    '-c', 'copy',
                    '-avoid_negative_ts', 'make_zero',
                    outputName
                ]);
                progressEl.style.width = '90%';

                // Delete the (large) input file before reading output to
                // reduce peak memory ‚Äî only the small clip remains in MEMFS.
                await ffmpegInstance.deleteFile(inputName).catch(() => {});

                const outputData = await ffmpegInstance.readFile(outputName);
                progressEl.style.width = '100%';

                // Cleanup output
                await ffmpegInstance.deleteFile(outputName).catch(() => {});

                overlay.classList.remove('active');

                const mimeType = ext === 'webm' ? 'video/webm' : 'video/mp4';
                return new Blob([outputData.buffer], { type: mimeType });
            } catch (err) {
                console.error('Clip extraction error:', err);
                overlay.classList.remove('active');
                showStatus('Failed to extract clip. The video format may not be supported.', 'error');
                return null;
            }
        }

        async function exportSingleClip(index) {
            const highlight = highlights[index];

            const loaded = await loadFFmpeg();
            if (!loaded) return;

            // Warn on very large videos (>500 MB)
            const fileSizeMB = videoFile ? videoFile.size / (1024 * 1024) : 0;
            if (fileSizeMB > 500) {
                showStatus('Large video ‚Äî export may be slow. If the page reloads, try a shorter video.', 'processing');
            }

            const blob = await extractClip(highlight);
            if (!blob) return;

            const ext = guessVideoExtension();
            const filename = `highlight-${index + 1}-${formatTime(highlight.timestamp).replace(':', 'm').replace('.', 's')}.${ext}`;

            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);

            showStatus(`Clip ${index + 1} exported!`, 'complete');
        }

        async function exportClip() {
            const enabled = getEnabledHighlights();
            if (enabled.length === 0) {
                showStatus('No enabled highlights to export.', 'error');
                return;
            }

            const loaded = await loadFFmpeg();
            if (!loaded) return;

            // Check file size and warn on very large videos (>500 MB)
            const fileSizeMB = videoFile ? videoFile.size / (1024 * 1024) : 0;
            if (fileSizeMB > 500) {
                showStatus('Large video ‚Äî export may be slow. If the page reloads, try a shorter video.', 'processing');
            }

            const ext = guessVideoExtension();

            const overlay = document.getElementById('ffmpegLoading');
            const titleEl = document.getElementById('ffmpegLoadingTitle');
            const textEl = document.getElementById('ffmpegLoadingText');
            const progressEl = document.getElementById('ffmpegProgressFill');
            overlay.classList.add('active');
            titleEl.textContent = 'Exporting Highlights...';
            progressEl.style.width = '5%';

            // Sort highlights by timestamp so the stitched video is in order
            const sorted = [...enabled].sort((a, b) => a.timestamp - b.timestamp);

            try {
                // ‚îÄ‚îÄ Phase 1: Extract each segment one at a time ‚îÄ‚îÄ
                // For each clip we: read video ‚Üí write to MEMFS ‚Üí extract segment
                // ‚Üí read segment back to JS ‚Üí wipe MEMFS.  This keeps peak WASM
                // memory at ~1√ó video size instead of video + all segments.
                const segmentBuffers = []; // small Uint8Arrays (~4 s each)
                const inputName = `input.${ext}`;

                for (let i = 0; i < sorted.length; i++) {
                    const h = sorted[i];
                    const segName = `seg.${ext}`;
                    const startTime = Math.max(0, h.timestamp - 3);
                    const duration = 4;

                    textEl.textContent = `Reading video for clip ${i + 1}...`;
                    let data = await getVideoData();
                    if (!data) throw new Error('Could not read video data');

                    await ffmpegInstance.writeFile(inputName, new Uint8Array(data));
                    data = null; // allow GC of the JS-heap copy

                    textEl.textContent = `Trimming clip ${i + 1} of ${sorted.length}...`;
                    await ffmpegInstance.exec([
                        '-ss', startTime.toFixed(2),
                        '-i', inputName,
                        '-t', duration.toFixed(2),
                        '-c', 'copy',
                        '-avoid_negative_ts', 'make_zero',
                        segName
                    ]);

                    // Read the small segment into JS, then wipe MEMFS completely
                    const segData = await ffmpegInstance.readFile(segName);
                    await ffmpegInstance.deleteFile(inputName).catch(() => {});
                    await ffmpegInstance.deleteFile(segName).catch(() => {});

                    segmentBuffers.push(segData);
                    progressEl.style.width = (5 + 60 * (i + 1) / sorted.length) + '%';
                }

                // ‚îÄ‚îÄ Phase 2: Concatenate the small segments ‚îÄ‚îÄ
                // MEMFS is empty here; we only write back the tiny clips.
                let outputBlob;
                const mimeType = ext === 'webm' ? 'video/webm' : 'video/mp4';

                if (segmentBuffers.length === 1) {
                    outputBlob = new Blob([segmentBuffers[0].buffer], { type: mimeType });
                } else {
                    textEl.textContent = 'Stitching clips together...';
                    const segmentNames = [];
                    for (let i = 0; i < segmentBuffers.length; i++) {
                        const name = `seg${i}.${ext}`;
                        await ffmpegInstance.writeFile(name, segmentBuffers[i]);
                        segmentNames.push(name);
                    }
                    segmentBuffers.length = 0; // free JS copies

                    const concatList = segmentNames.map(s => `file '${s}'`).join('\n');
                    await ffmpegInstance.writeFile('concat.txt', new TextEncoder().encode(concatList));

                    const outputName = `output.${ext}`;
                    await ffmpegInstance.exec([
                        '-f', 'concat',
                        '-safe', '0',
                        '-i', 'concat.txt',
                        '-c', 'copy',
                        outputName
                    ]);

                    // Cleanup segments + concat list
                    await ffmpegInstance.deleteFile('concat.txt').catch(() => {});
                    for (const s of segmentNames) await ffmpegInstance.deleteFile(s).catch(() => {});

                    const outputData = await ffmpegInstance.readFile(outputName);
                    await ffmpegInstance.deleteFile(outputName).catch(() => {});

                    outputBlob = new Blob([outputData.buffer], { type: mimeType });
                }
                progressEl.style.width = '95%';

                overlay.classList.remove('active');

                const url = URL.createObjectURL(outputBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `highlights.${ext}`;
                a.click();
                URL.revokeObjectURL(url);

                showStatus(`${enabled.length} clip(s) stitched and exported!`, 'complete');
            } catch (err) {
                console.error('Export error:', err);
                overlay.classList.remove('active');
                // Best-effort MEMFS cleanup on failure
                const filesToClean = [`input.${ext}`, `output.${ext}`, `seg.${ext}`, 'concat.txt'];
                for (let i = 0; i < enabled.length; i++) filesToClean.push(`seg${i}.${ext}`);
                for (const f of filesToClean) await ffmpegInstance.deleteFile(f).catch(() => {});
                showStatus('Failed to export clips. The video may be too large for your browser ‚Äî try fewer clips or a shorter video.', 'error');
            }
        }

        // ‚îÄ‚îÄ‚îÄ Native Share Sheet ‚îÄ‚îÄ‚îÄ

        async function shareSingleHighlight(index) {
            const highlight = highlights[index];
            const text = `Basketball Highlight #${index + 1} at ${formatTime(highlight.timestamp)} (Score: ${Math.round(highlight.confidence)})`;

            // Try sharing with video clip if FFmpeg is available
            if (navigator.canShare && videoFile) {
                try {
                    const loaded = await loadFFmpeg();
                    if (loaded) {
                        const blob = await extractClip(highlight);
                        if (blob) {
                            const ext = guessVideoExtension();
                            const file = new File([blob], `highlight-${index + 1}.${ext}`, { type: blob.type });
                            const shareData = { text, files: [file] };

                            if (navigator.canShare(shareData)) {
                                await navigator.share(shareData);
                                return;
                            }
                        }
                    }
                } catch (err) {
                    if (err.name === 'AbortError') return; // User cancelled
                    console.warn('File share failed, falling back to text share:', err);
                }
            }

            // Fallback: share text only
            try {
                await navigator.share({ text });
            } catch (err) {
                if (err.name !== 'AbortError') {
                    // Final fallback: copy to clipboard
                    navigator.clipboard.writeText(text).then(() => {
                        showStatus('Highlight info copied to clipboard!', 'complete');
                    });
                }
            }
        }

        async function shareHighlights() {
            const enabled = getEnabledHighlights();
            if (enabled.length === 0) {
                showStatus('No enabled highlights to share.', 'error');
                return;
            }

            const lines = enabled.map((h, i) =>
                `${i + 1}. ${formatTime(h.timestamp)} (Score: ${Math.round(h.confidence)})`
            );
            const text = `Basketball Highlights (${enabled.length} clips):\n${lines.join('\n')}`;

            try {
                await navigator.share({ text });
            } catch (err) {
                if (err.name !== 'AbortError') {
                    navigator.clipboard.writeText(text).then(() => {
                        showStatus('Highlights copied to clipboard!', 'complete');
                    });
                }
            }
        }
    </script>
</body>
</html>