<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Basketball Highlights Detector</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 32px;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 16px;
        }

        .content {
            padding: 30px;
        }

        .input-section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 12px;
            margin-bottom: 30px;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .tab {
            padding: 10px 20px;
            border: none;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .tab:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .tab.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        input[type="text"],
        input[type="file"] {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid #e1e8ed;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.2s;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .btn-primary:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: #e1e8ed;
            color: #333;
        }

        .btn-secondary:hover {
            background: #d1d8dd;
        }

        .video-section {
            display: grid;
            grid-template-columns: 1.5fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
            align-items: start;
        }

        @media (max-width: 968px) {
            .video-section {
                grid-template-columns: 1fr;
            }
        }

        /* Mobile-specific styles for phones */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .container {
                border-radius: 8px;
            }
            
            .header {
                padding: 15px 20px !important;
            }
            
            .header h1 {
                font-size: 20px !important;
            }
            
            .content {
                padding: 15px !important;
            }
            
            .upload-section {
                padding: 20px !important;
            }
            
            .tabs {
                flex-direction: column;
                gap: 8px;
            }
            
            .tab {
                width: 100%;
                justify-content: center;
            }
            
            .btn {
                padding: 12px 20px !important;
                font-size: 14px !important;
                width: 100%;
            }
            
            .video-section {
                padding: 15px !important;
            }
            
            .settings {
                padding: 15px !important;
            }
            
            /* Make sure video player is visible */
            .video-container {
                height: auto !important;
                min-height: 200px;
            }
            
            .video-container video {
                width: 100%;
                height: auto;
            }
            
            /* Stack highlights vertically on mobile */
            .highlights-container {
                max-height: none;
                overflow-y: auto;
            }
            
            .highlight-item {
                flex-direction: row;
                padding: 10px;
            }
            
            .highlight-thumbnail {
                width: 100px !important;
                height: 75px !important;
            }
            
            /* Make overlay more compact on mobile */
            #videoOverlay {
                padding: 8px 12px !important;
                font-size: 12px !important;
                bottom: 50px !important;
            }
            
            #videoOverlay button {
                width: 28px !important;
                height: 28px !important;
                font-size: 14px !important;
            }
            
            /* Guided setup on mobile */
            #setupGuide {
                padding: 15px !important;
                font-size: 14px;
            }
            
            #setupGuide .btn {
                font-size: 13px !important;
                padding: 10px 15px !important;
            }
        }

        @media (max-width: 480px) {
            body {
                padding: 5px;
            }
            
            .header h1 {
                font-size: 18px !important;
            }
            
            .content {
                padding: 10px !important;
            }
            
            .upload-section {
                padding: 15px !important;
            }
            
            /* Even more compact on very small screens */
            #videoOverlay {
                font-size: 11px !important;
                padding: 6px 10px !important;
            }
        }

        .video-column {
            position: sticky;
            top: 20px;
        }

        .video-section.theater-mode {
            grid-template-columns: 1fr;
            gap: 15px;
        }

        .video-section.theater-mode .video-column {
            position: relative;
        }

        .video-section.theater-mode .video-container {
            height: 70vh;
        }

        .video-section.theater-mode video {
            height: 100%;
            object-fit: contain;
        }

        .video-section.theater-mode #videoOverlay {
            bottom: 80px;
            font-size: 16px;
        }

        .video-section.theater-mode .highlights-container {
            max-height: none;
        }

        .video-section.theater-mode .highlights-list {
            display: flex;
            flex-direction: row;
            overflow-x: auto;
            overflow-y: hidden;
            gap: 12px;
            padding-bottom: 10px;
            scroll-behavior: smooth;
        }

        .video-section.theater-mode .highlight-item {
            flex-direction: column;
            min-width: 160px;
            max-width: 160px;
        }

        .video-section.theater-mode .highlight-thumbnail {
            width: 100%;
            height: 90px;
        }

        .highlight-item.playing {
            border-color: #667eea;
            background: #f0f4ff;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.3);
        }

        .video-container {
            background: #000;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }

        video {
            width: 100%;
            display: block;
        }

        canvas {
            display: none;
        }

        #selectionCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: default;
            display: none;
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
        }

        #selectionCanvas.active {
            display: block;
        }

        #selectionCanvas.has-regions {
            display: block;
            pointer-events: none;
        }

        .basket-overlay-controls {
            display: none;
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 200;
            gap: 10px;
            align-items: center;
        }

        .basket-overlay-controls.active {
            display: flex;
        }

        .basket-overlay-controls button {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .basket-overlay-controls .confirm-btn {
            background: #4CAF50;
            color: white;
        }

        .basket-overlay-controls .cancel-btn {
            background: rgba(255,255,255,0.9);
            color: #333;
        }

        .region-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .region-indicator {
            background: white;
            padding: 10px 12px;
            border-radius: 8px;
            font-size: 13px;
            color: #333;
            border: 2px solid #e1e8ed;
            flex: 1;
            min-width: 180px;
        }

        .region-indicator.set {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .region-indicator strong {
            color: #667eea;
            display: block;
            margin-bottom: 4px;
        }

        .region-badge {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            margin-left: 6px;
        }

        .help-text {
            font-size: 12px;
            color: #666;
            margin-top: 8px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 6px;
            border-left: 3px solid #667eea;
        }

        @keyframes fadeSlideIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes pulseGlow {
            0%, 100% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.5); }
            50% { box-shadow: 0 0 16px 4px rgba(76, 175, 80, 0.4); }
        }

        .highlights-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-height: calc(100vh - 100px);
            overflow-y: auto;
        }

        .highlights-list {
            display: grid;
            gap: 12px;
            max-height: none;
        }

        .progress-container {
            background: white;
            padding: 20px;
            border-radius: 12px;
            border: 2px solid #e1e8ed;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e1e8ed;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s;
        }

        .progress-text {
            text-align: center;
            color: #666;
            font-size: 14px;
        }

        .motion-chart-container {
            margin-top: 15px;
            background: #1a1a2e;
            border-radius: 8px;
            padding: 12px;
            position: relative;
        }

        .motion-chart-container canvas {
            display: block;
            width: 100%;
            height: 160px;
            border-radius: 4px;
        }

        .motion-chart-container h4 {
            color: #ccc;
            font-size: 12px;
            margin: 0 0 8px 0;
            font-weight: 600;
        }

        .motion-chart-legend {
            display: flex;
            gap: 12px;
            font-size: 10px;
            color: #aaa;
            margin-top: 6px;
            flex-wrap: wrap;
        }

        .motion-chart-legend span {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .motion-chart-legend .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
        }

        .status {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status.processing {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .status.complete {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .highlights-section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 12px;
        }

        .highlights-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .highlights-header h2 {
            font-size: 24px;
            color: #333;
        }

        .highlight-count {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
        }

        .highlights-list {
            display: grid;
            gap: 12px;
        }

        .highlight-item {
            background: white;
            padding: 12px;
            border-radius: 8px;
            display: flex;
            gap: 12px;
            align-items: center;
            transition: all 0.2s;
            cursor: pointer;
            border: 2px solid transparent;
        }

        .highlight-item:hover {
            border-color: #667eea;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
        }

        .highlight-thumbnail {
            width: 140px;
            height: 105px;
            background: #000;
            border-radius: 6px;
            overflow: hidden;
            flex-shrink: 0;
            position: relative;
        }

        .highlight-thumbnail img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .highlight-thumbnail .play-icon {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 24px;
            height: 24px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        .highlight-info {
            display: flex;
            flex-direction: column;
            gap: 4px;
            flex: 1;
        }

        .highlight-number {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
            flex-shrink: 0;
        }

        .highlight-time {
            font-size: 16px;
            font-weight: 600;
            color: #333;
        }

        .confidence {
            font-size: 11px;
            color: #666;
            background: #e1e8ed;
            padding: 3px 6px;
            border-radius: 4px;
            display: inline-block;
        }

        .region-label {
            font-size: 11px;
            color: #667eea;
            font-weight: 600;
        }

        .export-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px solid #e1e8ed;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #999;
        }

        .empty-state svg {
            width: 80px;
            height: 80px;
            margin-bottom: 20px;
            opacity: 0.3;
        }

        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 0.6s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .settings {
            background: white;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
        }

        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .setting-row:last-child {
            margin-bottom: 0;
        }

        .setting-label {
            font-size: 14px;
            color: #333;
            font-weight: 500;
        }

        .setting-description {
            font-size: 12px;
            color: #666;
            margin-top: 4px;
        }

        input[type="range"] {
            width: 150px;
        }

        .setting-value {
            font-size: 14px;
            font-weight: 600;
            color: #667eea;
            min-width: 40px;
            text-align: right;
        }

        /* Highlight toggle switch */
        .highlight-toggle {
            position: relative;
            width: 40px;
            height: 22px;
            flex-shrink: 0;
        }

        .highlight-toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background: #ccc;
            border-radius: 22px;
            transition: 0.2s;
        }

        .toggle-slider:before {
            content: "";
            position: absolute;
            height: 16px;
            width: 16px;
            left: 3px;
            bottom: 3px;
            background: white;
            border-radius: 50%;
            transition: 0.2s;
        }

        .highlight-toggle input:checked + .toggle-slider {
            background: #667eea;
        }

        .highlight-toggle input:checked + .toggle-slider:before {
            transform: translateX(18px);
        }

        .highlight-item.disabled {
            opacity: 0.4;
            border-color: #e1e8ed !important;
            box-shadow: none !important;
        }

        .highlight-item.disabled .highlight-thumbnail {
            filter: grayscale(1);
        }

        /* Highlight action buttons */
        .highlight-actions {
            display: flex;
            gap: 6px;
            margin-top: 6px;
        }

        .highlight-actions button {
            padding: 4px 8px;
            border: 1px solid #e1e8ed;
            background: white;
            border-radius: 6px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 4px;
            color: #555;
        }

        .highlight-actions button:hover {
            border-color: #667eea;
            color: #667eea;
            background: #f0f4ff;
        }

        .highlight-actions button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .highlight-actions button.loading {
            pointer-events: none;
        }

        /* FFmpeg loading overlay */
        .ffmpeg-loading {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.6);
            z-index: 9999;
            justify-content: center;
            align-items: center;
        }

        .ffmpeg-loading.active {
            display: flex;
        }

        .ffmpeg-loading-card {
            background: white;
            padding: 30px;
            border-radius: 16px;
            text-align: center;
            max-width: 320px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        .ffmpeg-loading-card h3 {
            margin-bottom: 12px;
            color: #333;
        }

        .ffmpeg-loading-card .progress-bar {
            margin-bottom: 8px;
        }

        .ffmpeg-loading-card p {
            font-size: 13px;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üèÄ Basketball Highlights Detector</h1>
            <p>Automatically find made baskets in your pickup game videos</p>
        </div>

        <div class="content">
            <!-- Input Section -->
            <div class="input-section">
                <div class="tabs">
                    <button class="tab active" id="fileTab" onclick="switchTab('file')">Choose File</button>
                    <button class="tab" id="urlTab" onclick="switchTab('url')">Use URL</button>
                </div>

                <div id="fileInput">
                    <div class="input-group" style="flex-direction: column;">
                        <input type="file" id="videoFile" accept="video/*" onchange="handleFileUpload(event)">
                    </div>
                </div>

                <div id="urlInput" style="display: none;">
                    <div class="input-group" style="display: flex; gap: 8px;">
                        <input type="text" id="videoUrl" placeholder="Paste video URL or Google Drive link" onkeypress="if(event.key==='Enter') loadVideo()" style="flex: 1;">
                        <button class="btn btn-primary" onclick="loadVideo()" style="white-space: nowrap; padding: 10px 20px;">Load Video</button>
                    </div>
                    <p style="font-size: 12px; color: #666; margin-top: 8px;">
                        üí° For Google Drive: Share the video ‚Üí Get link ‚Üí Change to "Anyone with the link" ‚Üí Paste link above
                    </p>
                </div>
            </div>

            <!-- Settings -->
            <div class="settings" id="settingsPanel" style="display: none;">
                <h3 style="margin-bottom: 15px; color: #333;">Detection Settings</h3>
                
                <div class="setting-row">
                    <div>
                        <div class="setting-label">Min. Gap Between Clips</div>
                        <div class="setting-description">Minimum seconds between detected baskets</div>
                    </div>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <input type="range" id="minGap" min="2" max="10" value="3" oninput="updateSettings()">
                        <span class="setting-value" id="minGapValue">3s</span>
                    </div>
                </div>
            </div>

            <!-- Video Section -->
            <div class="video-section" id="videoSection" style="display: none;">
                <div class="video-column">
                    <!-- Guided Setup Steps -->
                    <div id="setupGuide" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 12px; margin-bottom: 20px;">
                        <div style="text-align: center;">
                            <!-- Placeholder: replace src with your own image showing the basket selection area -->
                            <img id="setupGuideImage" src="" alt="Select the area around the basket" style="max-width: 100%; border-radius: 8px; display: none;">
                            <div id="setupGuidePlaceholder" style="background: rgba(255,255,255,0.15); border: 2px dashed rgba(255,255,255,0.4); border-radius: 8px; padding: 40px 20px; margin-bottom: 15px;">
                                <div style="font-size: 40px; margin-bottom: 8px;">üèÄ</div>
                                <div style="font-size: 14px; opacity: 0.9;">Guide image placeholder</div>
                            </div>
                        </div>
                        <div style="display: flex; gap: 10px;">
                            <button class="btn" onclick="skipToProcessing()" style="background: rgba(255,255,255,0.2); color: white; border: 1px solid rgba(255,255,255,0.3);">
                                Skip to Processing
                            </button>
                        </div>
                    </div>
                    
                    <div class="video-container">
                        <video id="videoPlayer" controls></video>
                        <video id="processingVideo" style="display: none;"></video>
                        <canvas id="canvas"></canvas>
                        <canvas id="selectionCanvas"></canvas>
                        <div class="basket-overlay-controls" id="basketOverlayControls">
                            <button class="cancel-btn" onclick="cancelOverlaySelection()">Cancel</button>
                            <button class="confirm-btn" onclick="confirmOverlaySelection()">Confirm</button>
                        </div>

                        <!-- Simplified Video Overlay - positioned below video controls -->
                        <div id="videoOverlay" style="display: none; position: absolute; bottom: 60px; left: 10px; right: 10px; background: rgba(0, 0, 0, 0.8); padding: 12px 16px; border-radius: 8px; color: white; font-family: sans-serif; z-index: 100; pointer-events: auto;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div style="display: flex; align-items: center; gap: 15px;">
                                    <button onclick="playPreviousClip()" style="background: rgba(255,255,255,0.2); border: none; color: white; width: 32px; height: 32px; border-radius: 50%; cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center; pointer-events: auto;">
                                        ‚óÄ
                                    </button>
                                    <div>
                                        <div style="font-size: 14px; font-weight: 600;">
                                            Clip <span id="overlayClipNumber">1</span> of <span id="overlayTotalClips">0</span>
                                        </div>
                                        <div style="font-size: 11px; color: #ddd; margin-top: 2px;">
                                            <span id="overlayTimestamp">0:00</span> ‚Ä¢ <span id="overlayClipTime">0.0s</span>/<span id="overlayClipDuration">4.0s</span>
                                        </div>
                                    </div>
                                    <button onclick="playNextClip()" style="background: rgba(255,255,255,0.2); border: none; color: white; width: 32px; height: 32px; border-radius: 50%; cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center; pointer-events: auto;">
                                        ‚ñ∂
                                    </button>
                                </div>
                                <div style="flex: 1; margin: 0 15px;">
                                    <div style="width: 100%; height: 4px; background: rgba(255, 255, 255, 0.3); border-radius: 2px; overflow: hidden;">
                                        <div id="overlayProgress" style="width: 0%; height: 100%; background: linear-gradient(90deg, #667eea 0%, #764ba2 100%); transition: width 0.1s linear;"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="region-controls">
                        <div class="region-indicator" id="regionIndicator">
                            <strong>üéØ Basket Regions:</strong>
                            <div id="regionList">None selected</div>
                        </div>
                    </div>
                    <div style="display: flex; gap: 10px; margin-top: 10px;">
                        <button class="btn btn-primary" onclick="startRegionSelection()" id="selectRegionBtn" style="flex: 1;">
                            üìç Add Basket Region
                        </button>
                        <button class="btn btn-secondary" onclick="clearLastRegion()" id="clearRegionBtn" style="display: none;">
                            ‚úï Remove
                        </button>
                    </div>
                    <div class="help-text" id="regionHelp" style="display: none; background: #f0f4ff; padding: 12px; border-radius: 8px; margin-top: 10px; font-size: 13px; color: #333;">
                        <strong>Drag the box</strong> over the basket, then <strong>drag corners</strong> to resize. Tap <strong>Confirm</strong> when done.
                    </div>
                    
                    <button class="btn btn-primary" onclick="processVideo()" id="processBtn" style="margin-top: 15px; width: 100%; display: none;">
                        <span>‚ñ∂ Play Clips</span>
                    </button>
                    
                    <button class="btn btn-primary" onclick="playAllHighlights()" id="playAllBtn" style="margin-top: 10px; width: 100%; display: none; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                        <span>‚ñ∂ Play All Highlights</span>
                    </button>
                </div>

                <div class="highlights-container">
                    <div class="progress-container" id="progressContainer" style="display: none;">
                        <h3 style="margin-bottom: 15px;">Processing...</h3>
                        <div class="progress-bar">
                            <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                        </div>
                        <div class="progress-text" id="progressText">0%</div>
                        <div style="font-size: 13px; color: #333; margin-top: 15px; padding: 12px; background: white; border-radius: 8px;">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                <span>üé¨ Frames Analyzed:</span>
                                <strong id="framesAnalyzed">0</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                <span>üèÄ Baskets Found:</span>
                                <strong id="basketsFound">0</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between;">
                                <span>‚è±Ô∏è Current Time:</span>
                                <strong id="currentProcessTime">0:00</strong>
                            </div>
                        </div>
                        <p style="font-size: 12px; color: #666; margin-top: 10px; text-align: center;">
                            üí° You can watch the main video while processing continues
                        </p>
                    </div>

                    <!-- Motion chart - single persistent element, visible once processing starts -->
                    <div class="motion-chart-container" id="motionChartContainer" style="display: none;">
                        <h4>Motion Analysis</h4>
                        <canvas id="motionChart"></canvas>
                        <div class="motion-chart-legend" id="motionChartLegend">
                            <span><span class="dot" style="background: #4fc3f7;"></span> Motion</span>
                            <span><span class="dot" style="background: rgba(255,82,82,0.6);"></span> Threshold</span>
                            <span><span class="dot" style="background: #4CAF50;"></span> Detection</span>
                        </div>
                    </div>

                    <!-- Highlights Section -->
                    <div class="highlights-section" id="highlightsSection" style="display: none;">
                        <div class="highlights-header">
                            <h2>Detected Highlights</h2>
                            <span class="highlight-count" id="highlightCount">0 baskets</span>
                        </div>
                        
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 6px; margin-bottom: 12px; font-size: 11px; color: #666;">
                            <strong>Debug:</strong> Anomaly Burst = brief spike above dynamic threshold | Sharp Spike = sudden 2x increase
                        </div>

                        <div class="highlights-list" id="highlightsList"></div>

                        <div class="export-section" style="display: flex; flex-wrap: wrap; gap: 8px;">
                            <button class="btn btn-secondary" onclick="exportTimestamps()">
                                üìã Copy Timestamps
                            </button>
                            <button class="btn btn-secondary" onclick="exportJSON()">
                                üíæ Download JSON
                            </button>
                            <button class="btn btn-secondary" onclick="exportClip()" id="exportClipBtn">
                                üé¨ Export Clips
                            </button>
                            <button class="btn btn-secondary" onclick="shareHighlights()" id="shareBtn" style="display: none;">
                                üì§ Share
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Status Messages -->
            <div id="statusMessage" style="display: none;"></div>

            <!-- FFmpeg Loading Overlay -->
            <div class="ffmpeg-loading" id="ffmpegLoading">
                <div class="ffmpeg-loading-card">
                    <h3 id="ffmpegLoadingTitle">Loading Video Editor...</h3>
                    <div class="progress-bar">
                        <div class="progress-fill" id="ffmpegProgressFill" style="width: 0%"></div>
                    </div>
                    <p id="ffmpegLoadingText">Downloading FFmpeg (~30 MB, first time only)</p>
                </div>
            </div>

            <!-- Empty State -->
            <div class="empty-state" id="emptyState">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"></circle>
                    <polygon points="10 8 16 12 10 16 10 8"></polygon>
                </svg>
                <h3>No video loaded</h3>
                <p>Upload a video file or paste a URL to get started</p>
            </div>
        </div>
    </div>

    <script>
        let currentTab = 'file';
        let videoFile = null;
        let highlights = [];
        let settings = {
            minGap: 3  // Minimum gap between clips in seconds
        };

        // Region selection variables - now supports multiple regions
        let basketRegions = [];
        let isSelectingRegion = false;
        let selectionCanvas = null;
        let selectionCtx = null;
        const MAX_REGIONS = 2;

        // Playback mode variables
        let isPlayingAll = false;
        let currentHighlightIndex = 0;
        let isTheaterMode = false;
        let playAllListener = null;

        // Motion chart data
        let chartData = [];        // {time, motions[], thresholds[], detected}
        let chartDetections = [];  // timestamps where detections fired

        // EMA anomaly detection state ‚Äî per region
        const EMA_ALPHA = 0.08;    // Smoothing factor ‚Äî lower = slower adaptation
        const ANOMALY_K = 2.5;     // Std deviations above mean to trigger
        const CEILING_K = 6;       // Motion above threshold * this = too big (person)
        const MIN_THRESHOLD = 2.5; // Floor so tiny noise doesn't trigger in dead-still scenes
        let regionEMAs = [];       // [{mean, variance, initialized}] per region

        // FFmpeg state
        let ffmpegInstance = null;
        let ffmpegLoaded = false;
        let ffmpegLoading = false;
        let videoDataForFFmpeg = null; // ArrayBuffer of original video

        function switchTab(tab) {
            currentTab = tab;
            document.getElementById('fileTab').classList.toggle('active', tab === 'file');
            document.getElementById('urlTab').classList.toggle('active', tab === 'url');
            document.getElementById('fileInput').style.display = tab === 'file' ? 'block' : 'none';
            document.getElementById('urlInput').style.display = tab === 'url' ? 'block' : 'none';
        }

        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (file) {
                videoFile = file;
                loadVideo();
            }
        }

        function loadVideo() {
            const video = document.getElementById('videoPlayer');
            const processingVideo = document.getElementById('processingVideo');

            if (currentTab === 'file' && videoFile) {
                const url = URL.createObjectURL(videoFile);
                video.removeAttribute('crossorigin');
                processingVideo.removeAttribute('crossorigin');
                video.src = url;
                processingVideo.src = url;
            } else if (currentTab === 'url') {
                let url = document.getElementById('videoUrl').value.trim();
                if (!url) {
                    showStatus('Please enter a video URL.', 'error');
                    return;
                }

                // Handle Google Drive links
                const isGoogleDrive = url.includes('drive.google.com') || url.includes('drive.usercontent.google.com');
                if (isGoogleDrive) {
                    const fileId = extractGoogleDriveId(url);
                    if (fileId) {
                        url = `https://drive.usercontent.google.com/download?id=${fileId}&export=download&confirm=t`;
                    } else {
                        showStatus('Could not extract file ID from Google Drive link. Make sure the link is a valid sharing URL.', 'error');
                        return;
                    }
                }

                showStatus('Loading video...', 'processing');

                video.src = url;
                processingVideo.src = url;
            }

            // Timeout for URL loading
            let loadTimeout = null;
            if (currentTab === 'url') {
                loadTimeout = setTimeout(() => {
                    const isGD = document.getElementById('videoUrl').value.includes('drive.google');
                    if (isGD) {
                        showStatus('Google Drive video is taking too long to load. The file may not be publicly shared, or Google may be blocking direct access. Try downloading the video and uploading it as a local file instead.', 'error');
                    } else {
                        showStatus('Video is taking too long to load. Check the URL and try again.', 'error');
                    }
                }, 20000);
            }

            video.onloadedmetadata = () => {
                if (loadTimeout) clearTimeout(loadTimeout);
                document.getElementById('emptyState').style.display = 'none';
                document.getElementById('videoSection').style.display = 'grid';
                document.getElementById('settingsPanel').style.display = 'block';
                highlights = [];
                basketRegions = [];
                videoDataForFFmpeg = null; // Clear cached video data for new video
                updateHighlightsDisplay();
                updateRegionDisplay();

                // Initialize selection canvas
                initSelectionCanvas();

                // Set up keyboard navigation
                setupKeyboardNavigation();

                showStatus('Video loaded successfully! Select basket regions to start.', 'complete');
            };

            video.onerror = () => {
                if (loadTimeout) clearTimeout(loadTimeout);
                const urlInput = document.getElementById('videoUrl').value || '';
                if (urlInput.includes('drive.google')) {
                    showStatus('Could not load Google Drive video. Make sure the file is set to "Anyone with the link can view" and try again. If it still fails, download the video and upload it as a local file.', 'error');
                } else {
                    showStatus('Error loading video. Check the URL or file format.', 'error');
                }
            };
        }

        function extractGoogleDriveId(url) {
            const patterns = [
                /\/d\/([a-zA-Z0-9-_]+)/,
                /id=([a-zA-Z0-9-_]+)/,
                /\/file\/d\/([a-zA-Z0-9-_]+)/
            ];

            for (const pattern of patterns) {
                const match = url.match(pattern);
                if (match) return match[1];
            }
            return null;
        }

        function updateSettings() {
            settings.minGap = parseInt(document.getElementById('minGap').value);
            document.getElementById('minGapValue').textContent = settings.minGap + 's';
        }

        function initSelectionCanvas() {
            const video = document.getElementById('videoPlayer');
            selectionCanvas = document.getElementById('selectionCanvas');
            selectionCtx = selectionCanvas.getContext('2d');

            // Match canvas size to video element
            const updateCanvasSize = () => {
                const rect = video.getBoundingClientRect();
                selectionCanvas.width = rect.width;
                selectionCanvas.height = rect.height;
                redrawRegion();
            };

            updateCanvasSize();
            window.addEventListener('resize', updateCanvasSize);

            // Interaction handlers for draggable overlay
            selectionCanvas.addEventListener('mousedown', handleOverlayPointerDown);
            selectionCanvas.addEventListener('mousemove', handleOverlayPointerMove);
            selectionCanvas.addEventListener('mouseup', handleOverlayPointerUp);
            selectionCanvas.addEventListener('touchstart', handleOverlayPointerDown, { passive: false });
            selectionCanvas.addEventListener('touchmove', handleOverlayPointerMove, { passive: false });
            selectionCanvas.addEventListener('touchend', handleOverlayPointerUp, { passive: false });
        }

        // Draggable/resizable overlay state
        let overlayRegion = null;      // The region being edited {x, y, width, height} in normalized coords
        let overlayDragType = null;    // 'move', 'tl', 'tr', 'bl', 'br' (corners)
        let overlayDragStart = null;   // {x, y} in normalized coords where drag started
        let overlayOriginal = null;    // Copy of region at drag start
        const HANDLE_SIZE = 22;        // px ‚Äî touch-friendly handle radius
        const MIN_REGION_SIZE = 0.08;  // Minimum 8% of video in either dimension

        function getPointerPos(e) {
            const rect = selectionCanvas.getBoundingClientRect();
            const touch = e.touches ? e.touches[0] : (e.changedTouches ? e.changedTouches[0] : e);
            return {
                px: (touch.clientX || e.clientX) - rect.left,
                py: (touch.clientY || e.clientY) - rect.top,
                nx: ((touch.clientX || e.clientX) - rect.left) / selectionCanvas.width,
                ny: ((touch.clientY || e.clientY) - rect.top) / selectionCanvas.height
            };
        }

        function hitTestOverlay(px, py) {
            if (!overlayRegion) return null;
            const r = overlayRegion;
            const x = r.x * selectionCanvas.width;
            const y = r.y * selectionCanvas.height;
            const w = r.width * selectionCanvas.width;
            const h = r.height * selectionCanvas.height;
            const hs = HANDLE_SIZE;

            // Test corners first (larger hit area for touch)
            if (Math.abs(px - x) < hs && Math.abs(py - y) < hs) return 'tl';
            if (Math.abs(px - (x + w)) < hs && Math.abs(py - y) < hs) return 'tr';
            if (Math.abs(px - x) < hs && Math.abs(py - (y + h)) < hs) return 'bl';
            if (Math.abs(px - (x + w)) < hs && Math.abs(py - (y + h)) < hs) return 'br';

            // Test inside box for move
            if (px >= x && px <= x + w && py >= y && py <= y + h) return 'move';

            return null;
        }

        function handleOverlayPointerDown(e) {
            if (!isSelectingRegion || !overlayRegion) return;
            e.preventDefault();
            const pos = getPointerPos(e);
            const hit = hitTestOverlay(pos.px, pos.py);
            if (!hit) return;

            overlayDragType = hit;
            overlayDragStart = { nx: pos.nx, ny: pos.ny };
            overlayOriginal = { ...overlayRegion };
        }

        function handleOverlayPointerMove(e) {
            if (!isSelectingRegion || !overlayRegion) return;
            e.preventDefault();
            const pos = getPointerPos(e);

            if (!overlayDragType) {
                // Update cursor based on hover
                const hit = hitTestOverlay(pos.px, pos.py);
                if (hit === 'move') selectionCanvas.style.cursor = 'grab';
                else if (hit) selectionCanvas.style.cursor = 'nwse-resize';
                else selectionCanvas.style.cursor = 'default';
                return;
            }

            // Active drag
            selectionCanvas.style.cursor = overlayDragType === 'move' ? 'grabbing' : 'nwse-resize';
            const dx = pos.nx - overlayDragStart.nx;
            const dy = pos.ny - overlayDragStart.ny;
            const o = overlayOriginal;

            if (overlayDragType === 'move') {
                overlayRegion.x = Math.max(0, Math.min(1 - o.width, o.x + dx));
                overlayRegion.y = Math.max(0, Math.min(1 - o.height, o.y + dy));
            } else {
                // Corner resize
                let newX = o.x, newY = o.y, newW = o.width, newH = o.height;

                if (overlayDragType === 'tl') {
                    newX = o.x + dx;
                    newY = o.y + dy;
                    newW = o.width - dx;
                    newH = o.height - dy;
                } else if (overlayDragType === 'tr') {
                    newY = o.y + dy;
                    newW = o.width + dx;
                    newH = o.height - dy;
                } else if (overlayDragType === 'bl') {
                    newX = o.x + dx;
                    newW = o.width - dx;
                    newH = o.height + dy;
                } else if (overlayDragType === 'br') {
                    newW = o.width + dx;
                    newH = o.height + dy;
                }

                // Enforce minimum size
                if (newW >= MIN_REGION_SIZE && newH >= MIN_REGION_SIZE) {
                    overlayRegion.x = Math.max(0, Math.min(1 - MIN_REGION_SIZE, newX));
                    overlayRegion.y = Math.max(0, Math.min(1 - MIN_REGION_SIZE, newY));
                    overlayRegion.width = Math.min(newW, 1 - overlayRegion.x);
                    overlayRegion.height = Math.min(newH, 1 - overlayRegion.y);
                }
            }

            drawOverlay();
        }

        function handleOverlayPointerUp(e) {
            if (!isSelectingRegion) return;
            e.preventDefault();
            overlayDragType = null;
            overlayDragStart = null;
            overlayOriginal = null;
            if (overlayRegion) {
                const hit = hitTestOverlay(getPointerPos(e).px, getPointerPos(e).py);
                selectionCanvas.style.cursor = hit === 'move' ? 'grab' : (hit ? 'nwse-resize' : 'default');
            }
        }

        function drawOverlay() {
            if (!selectionCanvas) return;
            selectionCtx.clearRect(0, 0, selectionCanvas.width, selectionCanvas.height);

            // Dark overlay
            selectionCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            selectionCtx.fillRect(0, 0, selectionCanvas.width, selectionCanvas.height);

            if (!overlayRegion) return;

            const r = overlayRegion;
            const x = r.x * selectionCanvas.width;
            const y = r.y * selectionCanvas.height;
            const w = r.width * selectionCanvas.width;
            const h = r.height * selectionCanvas.height;

            const colors = ['#667eea', '#f5576c'];
            const color = colors[basketRegions.length % colors.length];

            // Clear the region area (make it bright/visible)
            selectionCtx.clearRect(x, y, w, h);

            // Draw border
            selectionCtx.strokeStyle = color;
            selectionCtx.lineWidth = 3;
            selectionCtx.strokeRect(x, y, w, h);

            // Draw corner handles
            const hs = 12; // visual handle half-size
            const corners = [
                [x, y], [x + w, y],
                [x, y + h], [x + w, y + h]
            ];
            corners.forEach(([cx, cy]) => {
                selectionCtx.fillStyle = 'white';
                selectionCtx.beginPath();
                selectionCtx.arc(cx, cy, hs, 0, Math.PI * 2);
                selectionCtx.fill();
                selectionCtx.strokeStyle = color;
                selectionCtx.lineWidth = 3;
                selectionCtx.stroke();
            });

            // Draw label
            const label = `BASKET ${basketRegions.length + 1}`;
            selectionCtx.font = 'bold 12px sans-serif';
            const textWidth = selectionCtx.measureText(label).width;
            selectionCtx.fillStyle = color;
            selectionCtx.fillRect(x, y - 24, textWidth + 10, 22);
            selectionCtx.fillStyle = 'white';
            selectionCtx.fillText(label, x + 5, y - 9);
        }

        function toggleRegionSelection() {
            if (basketRegions.length >= MAX_REGIONS && !isSelectingRegion) {
                return;
            }

            isSelectingRegion = !isSelectingRegion;

            const canvas = document.getElementById('selectionCanvas');
            const btn = document.getElementById('selectRegionBtn');
            const help = document.getElementById('regionHelp');
            const overlayControls = document.getElementById('basketOverlayControls');

            if (isSelectingRegion) {
                canvas.classList.add('active');
                canvas.classList.remove('has-regions');
                btn.textContent = '‚úï Cancel Selection';
                btn.classList.remove('btn-secondary');
                btn.classList.add('btn-primary');
                help.style.display = 'block';
                overlayControls.classList.add('active');
                document.getElementById('videoPlayer').pause();

                // Create a default overlay region centered on the video
                overlayRegion = { x: 0.35, y: 0.25, width: 0.30, height: 0.35 };
                drawOverlay();
            } else {
                canvas.classList.remove('active');
                if (basketRegions.length > 0) canvas.classList.add('has-regions');
                btn.textContent = 'üìç Add Basket Region';
                btn.classList.remove('btn-primary');
                btn.classList.add('btn-secondary');
                help.style.display = 'none';
                overlayControls.classList.remove('active');
                overlayRegion = null;
                redrawRegion();
            }
        }

        function confirmOverlaySelection() {
            if (!overlayRegion) return;

            const regionNumber = basketRegions.length + 1;
            const colors = ['#667eea', '#f5576c'];

            const newRegion = {
                x: overlayRegion.x,
                y: overlayRegion.y,
                width: overlayRegion.width,
                height: overlayRegion.height,
                number: regionNumber,
                color: colors[(regionNumber - 1) % colors.length]
            };

            basketRegions.push(newRegion);
            updateRegionDisplay();
            toggleRegionSelection();
        }

        function cancelOverlaySelection() {
            if (isSelectingRegion) {
                toggleRegionSelection();
            }
        }

        function clearLastRegion() {
            if (basketRegions.length > 0) {
                basketRegions.pop();
                updateRegionDisplay();
                showStatus('Last basket region removed.', 'complete');
            }
        }

        function clearAllRegions() {
            basketRegions = [];
            updateRegionDisplay();
            showStatus('All basket regions cleared. Will use full frame detection.', 'complete');
        }

        function updateRegionDisplay() {
            const indicator = document.getElementById('regionIndicator');
            const regionList = document.getElementById('regionList');
            const selectBtn = document.getElementById('selectRegionBtn');

            if (basketRegions.length === 0) {
                regionList.innerHTML = 'None selected';
                indicator.classList.remove('set');
                document.getElementById('clearRegionBtn').style.display = 'none';
                selectBtn.disabled = false;
                selectBtn.textContent = 'üìç Add Basket Region';
            } else {
                const badges = basketRegions.map((r, i) =>
                    `<span class="region-badge" style="background: ${r.color}">Region ${r.number}</span>`
                ).join(' ');
                regionList.innerHTML = badges;
                indicator.classList.add('set');
                document.getElementById('clearRegionBtn').style.display = 'inline-flex';
                selectBtn.disabled = basketRegions.length >= MAX_REGIONS;
                if (basketRegions.length >= MAX_REGIONS) {
                    selectBtn.textContent = 'Max regions reached';
                } else {
                    selectBtn.textContent = 'üìç Add Basket Region';
                }
            }
            
            redrawRegion();
            updateGuidedWorkflow();
        }

        function updateGuidedWorkflow() {
            const processBtn = document.getElementById('processBtn');
            const setupGuide = document.getElementById('setupGuide');
            const nextStepsPanel = document.getElementById('nextStepsPanel');

            if (basketRegions.length === 0) {
                processBtn.style.display = 'none';
                setupGuide.style.display = 'block';
                if (nextStepsPanel) nextStepsPanel.style.display = 'none';
            } else {
                processBtn.style.display = 'none'; // hide standalone button; next-steps panel takes over
                setupGuide.style.display = 'none';

                if (!nextStepsPanel) {
                    // Create the next-steps panel once
                    const panel = document.createElement('div');
                    panel.id = 'nextStepsPanel';
                    panel.style.cssText = 'margin-top: 15px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 18px; border-radius: 12px; color: white; animation: fadeSlideIn 0.4s ease;';
                    processBtn.parentNode.insertBefore(panel, processBtn);
                }

                const panel = document.getElementById('nextStepsPanel');
                panel.style.display = 'block';

                if (basketRegions.length < MAX_REGIONS) {
                    panel.innerHTML = `
                        <div style="font-weight: 700; font-size: 15px; margin-bottom: 12px;">Basket ${basketRegions.length} selected!</div>
                        <div style="display: flex; gap: 10px;">
                            <button class="btn" onclick="processVideo()" style="flex: 1; background: #4CAF50; color: white; border: none; font-weight: 700; font-size: 15px; padding: 14px;">
                                Start Detection
                            </button>
                            <button class="btn" onclick="startRegionSelection()" style="flex: 1; background: rgba(255,255,255,0.2); color: white; border: 1px solid rgba(255,255,255,0.4); font-size: 14px; padding: 14px;">
                                Add Basket ${basketRegions.length + 1}
                            </button>
                        </div>
                        <div style="font-size: 12px; opacity: 0.8; margin-top: 8px; text-align: center;">Adding both baskets improves accuracy</div>
                    `;
                } else {
                    panel.innerHTML = `
                        <div style="font-weight: 700; font-size: 15px; margin-bottom: 12px;">Both baskets selected!</div>
                        <button class="btn" onclick="processVideo()" style="width: 100%; background: #4CAF50; color: white; border: none; font-weight: 700; font-size: 16px; padding: 16px; animation: pulseGlow 1.5s ease-in-out infinite;">
                            Start Detection
                        </button>
                    `;
                }

                // Scroll the panel into view
                panel.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }

        function startRegionSelection() {
            if (basketRegions.length >= MAX_REGIONS) {
                showStatus(`Maximum ${MAX_REGIONS} basket regions allowed.`, 'complete');
                return;
            }
            toggleRegionSelection();
        }

        function skipToProcessing() {
            document.getElementById('setupGuide').style.display = 'none';
            // If no baskets selected yet, show the process button directly
            if (basketRegions.length === 0) {
                document.getElementById('processBtn').style.display = 'block';
                document.getElementById('processBtn').innerHTML = '<span>‚ñ∂ Start Detection (Full Frame)</span>';
            }
            showStatus('You can still add basket regions before processing for better accuracy.', 'complete');
        }

        function redrawRegion() {
            if (!selectionCanvas) return;

            selectionCtx.clearRect(0, 0, selectionCanvas.width, selectionCanvas.height);

            // Manage has-regions class for passive display
            if (basketRegions.length > 0 && !isSelectingRegion) {
                selectionCanvas.classList.add('has-regions');

                // Draw semi-transparent overlay
                selectionCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                selectionCtx.fillRect(0, 0, selectionCanvas.width, selectionCanvas.height);

                // Draw each saved region
                basketRegions.forEach(region => {
                    const x = region.x * selectionCanvas.width;
                    const y = region.y * selectionCanvas.height;
                    const width = region.width * selectionCanvas.width;
                    const height = region.height * selectionCanvas.height;

                    // Clear the region
                    selectionCtx.clearRect(x, y, width, height);

                    // Draw colored border
                    selectionCtx.strokeStyle = region.color;
                    selectionCtx.lineWidth = 3;
                    selectionCtx.strokeRect(x, y, width, height);

                    // Draw label with background ‚Äî position above the box
                    const label = `BASKET ${region.number}`;
                    selectionCtx.font = 'bold 12px sans-serif';
                    const textWidth = selectionCtx.measureText(label).width;
                    const labelY = y > 26 ? y - 26 : y + height + 4;

                    selectionCtx.fillStyle = region.color;
                    selectionCtx.fillRect(x, labelY, textWidth + 10, 22);

                    selectionCtx.fillStyle = 'white';
                    selectionCtx.fillText(label, x + 5, labelY + 15);
                });
            } else if (!isSelectingRegion) {
                selectionCanvas.classList.remove('has-regions');
            }
        }

        function drawMotionChart() {
            const container = document.getElementById('motionChartContainer');
            const canvas = document.getElementById('motionChart');
            if (!canvas || chartData.length === 0) return;

            // Ensure container is visible before measuring
            if (container.style.display === 'none') {
                container.style.display = 'block';
            }

            // Size canvas to match CSS layout (avoids blurry rendering)
            const cssW = canvas.clientWidth;
            const cssH = canvas.clientHeight;
            if (cssW === 0 || cssH === 0) return; // not laid out yet
            canvas.width = cssW * 2;
            canvas.height = cssH * 2;
            const ctx = canvas.getContext('2d');
            ctx.scale(2, 2);

            const W = cssW;
            const H = cssH;
            const pad = { top: 8, bottom: 18, left: 30, right: 8 };
            const plotW = W - pad.left - pad.right;
            const plotH = H - pad.top - pad.bottom;
            const duration = document.getElementById('processingVideo').duration || 1;

            // Background
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, W, H);

            // Collect all motion and threshold values across all regions
            const regionCount = chartData.length > 0 ? chartData[0].motions.length : 1;
            const allValues = [];
            chartData.forEach(d => {
                d.motions.forEach(m => allValues.push(m));
                d.thresholds.forEach(t => allValues.push(t));
            });

            // Cap y-axis at 95th percentile for readability
            allValues.sort((a, b) => a - b);
            const p95 = allValues[Math.floor(allValues.length * 0.95)] || 10;
            const maxY = Math.max(10, p95 * 1.2);

            // Grid lines
            ctx.strokeStyle = 'rgba(255,255,255,0.08)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = pad.top + (plotH / 4) * i;
                ctx.beginPath();
                ctx.moveTo(pad.left, y);
                ctx.lineTo(W - pad.right, y);
                ctx.stroke();
            }

            // Y-axis labels
            ctx.fillStyle = '#666';
            ctx.font = '9px sans-serif';
            ctx.textAlign = 'right';
            for (let i = 0; i <= 4; i++) {
                const y = pad.top + (plotH / 4) * i;
                const val = Math.round(maxY * (1 - i / 4));
                ctx.fillText(val, pad.left - 3, y + 3);
            }

            // X-axis time labels
            ctx.textAlign = 'center';
            const timeSteps = Math.max(1, Math.min(6, Math.ceil(duration / 30)));
            for (let i = 0; i <= timeSteps; i++) {
                const t = (duration / timeSteps) * i;
                const x = pad.left + (t / duration) * plotW;
                ctx.fillText(formatTime(t), x, H - 2);
            }

            // Detection markers (green vertical bars)
            chartDetections.forEach(t => {
                const x = pad.left + (t / duration) * plotW;
                ctx.fillStyle = 'rgba(76, 175, 80, 0.25)';
                ctx.fillRect(x - 3, pad.top, 6, plotH);
                ctx.fillStyle = '#4CAF50';
                ctx.beginPath();
                ctx.arc(x, pad.top + 4, 3, 0, Math.PI * 2);
                ctx.fill();
            });

            // Line drawing helper ‚Äî clamps values at maxY
            function line(color, lw, dash, fn) {
                ctx.strokeStyle = color;
                ctx.lineWidth = lw;
                if (dash) ctx.setLineDash(dash);
                ctx.beginPath();
                chartData.forEach((d, i) => {
                    const x = pad.left + (d.time / duration) * plotW;
                    const y = pad.top + plotH * (1 - Math.min(1, fn(d) / maxY));
                    i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
                });
                ctx.stroke();
                if (dash) ctx.setLineDash([]);
            }

            // Colors per region
            const motionColors = ['#4fc3f7', '#ce93d8'];
            const threshColors = ['rgba(255, 82, 82, 0.6)', 'rgba(255, 167, 38, 0.6)'];

            // Draw per-region threshold and motion lines
            for (let r = 0; r < regionCount; r++) {
                line(threshColors[r % threshColors.length], 1, [3, 3], d => d.thresholds[r]);
                line(motionColors[r % motionColors.length], 1.5, null, d => d.motions[r]);
            }
        }

        async function processVideo() {
            const video = document.getElementById('processingVideo'); // Use hidden video
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = 320;
            canvas.height = 180;
            
            highlights = [];
            chartData = [];
            chartDetections = [];

            // Update legend for number of regions
            const legendEl = document.getElementById('motionChartLegend');
            if (basketRegions.length >= 2) {
                legendEl.innerHTML =
                    '<span><span class="dot" style="background: #4fc3f7;"></span> Basket 1</span>' +
                    '<span><span class="dot" style="background: #ce93d8;"></span> Basket 2</span>' +
                    '<span><span class="dot" style="background: rgba(255,82,82,0.6);"></span> Threshold</span>' +
                    '<span><span class="dot" style="background: #4CAF50;"></span> Detection</span>';
            } else {
                legendEl.innerHTML =
                    '<span><span class="dot" style="background: #4fc3f7;"></span> Motion</span>' +
                    '<span><span class="dot" style="background: rgba(255,82,82,0.6);"></span> Threshold</span>' +
                    '<span><span class="dot" style="background: #4CAF50;"></span> Detection</span>';
            }

            document.getElementById('processBtn').disabled = true;
            const nsp = document.getElementById('nextStepsPanel');
            if (nsp) nsp.style.display = 'none';
            document.getElementById('progressContainer').style.display = 'block';
            document.getElementById('highlightsSection').style.display = 'block';
            document.getElementById('motionChartContainer').style.display = 'block';

            const regionMsg = basketRegions.length > 0
                ? ` Detecting motion in ${basketRegions.length} region(s).`
                : ' Using full-frame motion detection.';
            showStatus('Processing video...' + regionMsg, 'processing');

            const duration = video.duration;
            const fps = 3;
            const interval = 1 / fps;

            let previousFrame = null;
            let framesProcessed = 0;
            const regionCount = Math.max(1, basketRegions.length);

            // Per-region motion histories
            let motionHistories = [];
            for (let i = 0; i < regionCount; i++) motionHistories.push([]);

            // Reset EMA state
            initRegionEMAs();

            for (let time = 0; time < duration; time += interval) {
                video.currentTime = time;

                await new Promise(resolve => {
                    let resolved = false;
                    const done = () => { if (!resolved) { resolved = true; resolve(); } };
                    const timeout = setTimeout(done, 5000);
                    video.addEventListener('seeked', () => { clearTimeout(timeout); done(); }, { once: true });
                });

                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                let currentFrame;
                try {
                    currentFrame = ctx.getImageData(0, 0, canvas.width, canvas.height);
                } catch (e) {
                    // Tainted canvas ‚Äî cross-origin video blocks pixel reading
                    document.getElementById('processBtn').disabled = false;
                    document.getElementById('progressContainer').style.display = 'none';
                    showStatus('Cannot process this video due to cross-origin restrictions. The video server does not allow pixel-level access from the browser. Please download the video and upload it as a local file instead.', 'error');
                    return;
                }

                if (previousFrame) {
                    const motions = detectMotion(previousFrame, currentFrame);

                    // Push each region's motion into its own history
                    motions.forEach((m, i) => {
                        motionHistories[i].push(m);
                        if (motionHistories[i].length > 15) motionHistories[i].shift();
                    });

                    // Record for chart: store per-region motions and thresholds
                    const thresholds = motions.map((_, i) => getRegionThreshold(i));
                    chartData.push({ time, motions, thresholds, detected: false });

                    // Detect potential basket (need at least 4 frames per region)
                    const minHistory = Math.min(...motionHistories.map(h => h.length));
                    if (minHistory >= 4) {
                        const detectionResult = calculateBasketScore(motionHistories, time);
                        
                        if (detectionResult.passes) {
                            const lastHighlight = highlights[highlights.length - 1];
                            if (!lastHighlight || time - lastHighlight.timestamp > settings.minGap) {
                                // Mark on chart
                                chartDetections.push(time);
                                if (chartData.length > 0) chartData[chartData.length - 1].detected = true;

                                // Capture thumbnail with detection data
                                const thumbnail = captureThumbnail(video, canvas, ctx, {
                                    motion: detectionResult.motion,
                                    rim: detectionResult.rim,
                                    ball: detectionResult.ball,
                                    score: detectionResult.score,
                                    regionIndex: detectionResult.regionIndex
                                });
                                
                                highlights.push({
                                    timestamp: time,
                                    confidence: Math.min(100, detectionResult.score),
                                    thumbnail: thumbnail,
                                    enabled: true,
                                    reasons: detectionResult.reasons,
                                    debugData: {
                                        motion: detectionResult.motion,
                                        rim: detectionResult.rim,
                                        ball: detectionResult.ball,
                                        motionDrop: detectionResult.motionDrop,
                                        rimVisible: detectionResult.rimVisible,
                                        ballPresent: detectionResult.ballPresent
                                    }
                                });
                                
                                // Update UI in real-time
                                updateHighlightsDisplay();
                                document.getElementById('basketsFound').textContent = highlights.length;
                                
                                // Start playing clips as soon as we get the first one
                                if (highlights.length === 1 && !isPlayingAll) {
                                    // Hide the setup guide
                                    document.getElementById('setupGuide').style.display = 'none';
                                    
                                    // Start playing immediately
                                    setTimeout(() => {
                                        playAllHighlights();
                                    }, 500); // Small delay to let UI update
                                }
                            }
                        }
                    }
                }
                
                previousFrame = currentFrame;
                framesProcessed++;
                
                const progress = Math.floor((time / duration) * 100);
                document.getElementById('progressFill').style.width = progress + '%';
                document.getElementById('progressText').textContent = progress + '%';
                document.getElementById('framesAnalyzed').textContent = framesProcessed;
                document.getElementById('currentProcessTime').textContent = formatTime(time);
                
                // Allow UI to update and redraw chart every 15 frames
                if (framesProcessed % 15 === 0) {
                    drawMotionChart();
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }
            
            document.getElementById('processBtn').disabled = false;
            document.getElementById('progressContainer').style.display = 'none';
            document.getElementById('setupGuide').style.display = 'none';
            drawMotionChart();
            
            video.currentTime = 0;
            updateHighlightsDisplay();
            
            // Only auto-start if not already playing (might have started on first clip)
            if (highlights.length > 0 && !isPlayingAll) {
                showStatus(`Processing complete! Found ${highlights.length} clip(s). Playing now...`, 'complete');
                setTimeout(() => {
                    playAllHighlights();
                }, 1000);
            } else if (isPlayingAll) {
                showStatus(`Processing complete! Found ${highlights.length} clip(s) total.`, 'complete');
            } else {
                showStatus(`Processing complete! No clips detected.`, 'complete');
            }
        }

        // Returns array of per-region motion values, or [fullFrameMotion] if no regions
        function detectMotion(frame1, frame2) {
            const data1 = frame1.data;
            const data2 = frame2.data;
            const width = frame1.width;
            const height = frame1.height;

            if (basketRegions.length > 0) {
                return basketRegions.map(region => {
                    const startX = Math.floor(region.x * width);
                    const startY = Math.floor(region.y * height);
                    const endX = Math.floor((region.x + region.width) * width);
                    const endY = Math.floor((region.y + region.height) * height);

                    let regionDiff = 0;
                    let regionCount = 0;

                    for (let y = startY; y < endY; y += 2) {
                        for (let x = startX; x < endX; x += 2) {
                            const idx = (y * width + x) * 4;
                            const r = Math.abs(data1[idx] - data2[idx]);
                            const g = Math.abs(data1[idx + 1] - data2[idx + 1]);
                            const b = Math.abs(data1[idx + 2] - data2[idx + 2]);
                            regionDiff += (r + g + b) / 3;
                            regionCount++;
                        }
                    }

                    return regionCount > 0 ? regionDiff / regionCount : 0;
                });
            } else {
                let diff = 0;
                let count = 0;
                for (let i = 0; i < data1.length; i += 40) {
                    const r = Math.abs(data1[i] - data2[i]);
                    const g = Math.abs(data1[i + 1] - data2[i + 1]);
                    const b = Math.abs(data1[i + 2] - data2[i + 2]);
                    diff += (r + g + b) / 3;
                    count++;
                }
                return [diff / count];
            }
        }

        function initRegionEMAs() {
            const count = Math.max(1, basketRegions.length);
            regionEMAs = [];
            for (let i = 0; i < count; i++) {
                regionEMAs.push({ mean: 0, variance: 0, initialized: false });
            }
        }

        function updateRegionEMA(regionIdx, motion) {
            const ema = regionEMAs[regionIdx];
            if (!ema.initialized) {
                ema.mean = motion;
                ema.variance = 0;
                ema.initialized = true;
                return;
            }
            const diff = motion - ema.mean;
            ema.mean += EMA_ALPHA * diff;
            ema.variance = (1 - EMA_ALPHA) * (ema.variance + EMA_ALPHA * diff * diff);
        }

        function getRegionThreshold(regionIdx) {
            const ema = regionEMAs[regionIdx];
            if (!ema || !ema.initialized) return MIN_THRESHOLD;
            const stdDev = Math.sqrt(Math.max(0, ema.variance));
            return Math.max(MIN_THRESHOLD, ema.mean + ANOMALY_K * stdDev);
        }

        // motionHistories: array of arrays, one per region
        // Each inner array is the last N motion values for that region
        function calculateBasketScore(motionHistories, time) {
            let bestScore = 0;
            let bestReasons = [];
            let bestMotion = 0;
            let bestThreshold = MIN_THRESHOLD;
            let bestRegionIdx = 0;

            motionHistories.forEach((history, rIdx) => {
                const currentMotion = history[history.length - 1];
                const threshold = getRegionThreshold(rIdx);
                const ceiling = threshold * CEILING_K;

                const isAnomaly = currentMotion > threshold;
                const isTooBig = currentMotion > ceiling;

                // Brief burst check in last 4 frames
                const recentAbove = history.slice(-4).filter(m => m > threshold).length;
                const isBrief = recentAbove >= 1 && recentAbove <= 2;
                const isSustained = recentAbove >= 3;

                let score = 0;
                let reasons = [];

                if (isTooBig) {
                    // Motion too large ‚Äî likely a person, not a ball
                    score = 0;
                    reasons.push('(too large)');
                } else if (isAnomaly && isBrief) {
                    score += 70;
                    reasons.push('Anomaly Burst');
                } else if (isAnomaly && !isSustained) {
                    score += 40;
                    reasons.push('Anomaly');
                }

                // Spike/drop pattern bonus
                const avgRecent = history.slice(-2).reduce((a, b) => a + b) / 2;
                const earlier = history.slice(-5, -2);
                const avgEarlier = earlier.length > 0 ? earlier.reduce((a, b) => a + b) / earlier.length : 0;
                if (avgRecent > avgEarlier * 2 && avgRecent > threshold * 0.8 && !isTooBig) {
                    score += 20;
                    reasons.push('Sharp Spike');
                }

                if (isSustained) {
                    score = Math.max(0, score - 50);
                    reasons.push('(sustained)');
                }

                // Update EMA AFTER scoring
                updateRegionEMA(rIdx, currentMotion);

                if (score > bestScore) {
                    bestScore = score;
                    bestReasons = reasons;
                    bestMotion = currentMotion;
                    bestThreshold = threshold;
                    bestRegionIdx = rIdx;
                }
            });

            return {
                score: bestScore, motion: bestMotion, rim: 0, ball: 0,
                threshold: bestThreshold, regionIndex: bestRegionIdx,
                motionDrop: false, rimVisible: false, ballPresent: false,
                reasons: bestReasons,
                passes: bestScore >= 50
            };
        }

        function captureThumbnail(video, canvas, ctx, detectionData) {
            // Draw full frame first
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            
            // If there are regions, crop to show the region where detection happened
            if (basketRegions.length > 0) {
                const region = detectionData.regionIndex !== undefined 
                    ? basketRegions[detectionData.regionIndex] 
                    : basketRegions[0];
                
                const sx = Math.floor(region.x * canvas.width);
                const sy = Math.floor(region.y * canvas.height);
                const sw = Math.floor(region.width * canvas.width);
                const sh = Math.floor(region.height * canvas.height);
                
                // Create a thumbnail canvas
                const thumbCanvas = document.createElement('canvas');
                thumbCanvas.width = 320;
                thumbCanvas.height = 240;
                const thumbCtx = thumbCanvas.getContext('2d');
                
                // Draw the cropped region scaled to thumbnail size
                thumbCtx.drawImage(
                    video,
                    sx, sy, sw, sh,  // Source
                    0, 0, 320, 240   // Destination
                );
                
                // Add debug overlay showing detection scores
                thumbCtx.fillStyle = 'rgba(0, 0, 0, 0.75)';
                thumbCtx.fillRect(0, 200, 320, 40);
                
                thumbCtx.fillStyle = 'white';
                thumbCtx.font = 'bold 13px monospace';
                thumbCtx.fillText(`Motion: ${detectionData.motion.toFixed(1)}`, 8, 218);
                thumbCtx.fillText(`Rim: ${detectionData.rim.toFixed(1)}`, 8, 233);
                thumbCtx.fillText(`Ball: ${detectionData.ball.toFixed(1)}`, 168, 218);
                thumbCtx.fillText(`Score: ${detectionData.score.toFixed(0)}`, 168, 233);
                
                return thumbCanvas.toDataURL('image/jpeg', 0.8);
            }
            
            // Return full frame thumbnail if no regions
            const thumbCanvas = document.createElement('canvas');
            thumbCanvas.width = 320;
            thumbCanvas.height = 240;
            const thumbCtx = thumbCanvas.getContext('2d');
            thumbCtx.drawImage(canvas, 0, 0, 320, 240);
            
            // Add debug info
            thumbCtx.fillStyle = 'rgba(0, 0, 0, 0.75)';
            thumbCtx.fillRect(0, 200, 320, 40);
            thumbCtx.fillStyle = 'white';
            thumbCtx.font = 'bold 13px monospace';
            thumbCtx.fillText(`Motion: ${detectionData.motion.toFixed(1)}`, 8, 218);
            thumbCtx.fillText(`Rim: ${detectionData.rim.toFixed(1)}`, 8, 233);
            thumbCtx.fillText(`Ball: ${detectionData.ball.toFixed(1)}`, 168, 218);
            thumbCtx.fillText(`Score: ${detectionData.score.toFixed(0)}`, 168, 233);
            
            return thumbCanvas.toDataURL('image/jpeg', 0.8);
        }

        function getEnabledHighlights() {
            return highlights.filter(h => h.enabled !== false);
        }

        function toggleHighlight(index, event) {
            event.stopPropagation();
            highlights[index].enabled = !highlights[index].enabled;
            updateHighlightsDisplay();
        }

        function updateHighlightsDisplay() {
            const section = document.getElementById('highlightsSection');
            const list = document.getElementById('highlightsList');
            const count = document.getElementById('highlightCount');

            if (highlights.length === 0) {
                section.style.display = 'none';
                return;
            }

            section.style.display = 'block';
            const enabledCount = getEnabledHighlights().length;
            count.textContent = enabledCount + ' of ' + highlights.length + (highlights.length === 1 ? ' basket' : ' baskets');

            const canShare = !!navigator.share;
            const shareBtn = document.getElementById('shareBtn');
            if (shareBtn) shareBtn.style.display = canShare ? 'inline-flex' : 'none';

            list.innerHTML = highlights.map((h, i) => {
                const reasons = h.reasons ? h.reasons.join(', ') : 'Unknown';
                const debugData = h.debugData || {};
                const isEnabled = h.enabled !== false;
                const disabledClass = isEnabled ? '' : ' disabled';

                return `
                <div class="highlight-item${disabledClass}" onclick="jumpToHighlight(${h.timestamp})" title="Click to play">
                    ${h.thumbnail ? `
                        <div class="highlight-thumbnail">
                            <img src="${h.thumbnail}" alt="Basket at ${formatTime(h.timestamp)}">
                            <div class="play-icon">‚ñ∂</div>
                        </div>
                    ` : ''}
                    <div class="highlight-number">${i + 1}</div>
                    <div class="highlight-info">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div class="highlight-time">${formatTime(h.timestamp)}</div>
                            <label class="highlight-toggle" onclick="event.stopPropagation()">
                                <input type="checkbox" ${isEnabled ? 'checked' : ''} onchange="toggleHighlight(${i}, event)">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                        <div>
                            <span class="confidence">Score: ${Math.round(h.confidence)}</span>
                        </div>
                        <div style="font-size: 10px; color: #667eea; margin-top: 4px;">
                            ${reasons}
                        </div>
                        ${debugData.motion !== undefined ? `
                        <div style="font-size: 9px; color: #999; margin-top: 4px; font-family: monospace;">
                            M:${debugData.motion.toFixed(1)}
                            R:${debugData.rim.toFixed(1)}
                            B:${debugData.ball.toFixed(1)}
                            ${debugData.motionDrop ? 'üìâ' : ''}
                            ${debugData.rimVisible ? 'üéØ' : ''}
                            ${debugData.ballPresent ? 'üèÄ' : ''}
                        </div>
                        ` : ''}
                        <div class="highlight-actions" onclick="event.stopPropagation()">
                            <button onclick="exportSingleClip(${i})" title="Export this clip">üé¨ Clip</button>
                            ${canShare ? `<button onclick="shareSingleHighlight(${i})" title="Share this highlight">üì§ Share</button>` : ''}
                        </div>
                    </div>
                </div>
            `}).join('');

            // Show Play All button when highlights are available
            const playAllBtn = document.getElementById('playAllBtn');
            if (playAllBtn) {
                playAllBtn.style.display = enabledCount > 0 ? 'block' : 'none';
            }

            // Enable playback controls when highlights are available
            enablePlaybackControls();
        }

        function jumpToHighlight(timestamp) {
            const video = document.getElementById('videoPlayer');
            const startTime = Math.max(0, timestamp - 3); // Start 3 seconds before
            const endTime = timestamp + 1; // Stop 1 second after
            
            video.currentTime = startTime;
            video.play();
            
            // Set up listener to stop at end time
            const stopListener = () => {
                if (video.currentTime >= endTime) {
                    video.pause();
                    video.removeEventListener('timeupdate', stopListener);
                }
            };
            
            video.addEventListener('timeupdate', stopListener);
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            const ms = Math.floor((seconds % 1) * 10);
            return `${mins}:${secs.toString().padStart(2, '0')}.${ms}`;
        }

        function exportTimestamps() {
            const enabled = getEnabledHighlights();
            const text = enabled.map((h, i) =>
                `${i + 1}. ${formatTime(h.timestamp)} (${Math.round(h.confidence)}% confidence)`
            ).join('\n');

            navigator.clipboard.writeText(text).then(() => {
                showStatus(`${enabled.length} timestamp(s) copied to clipboard!`, 'complete');
            });
        }

        function exportJSON() {
            const enabled = getEnabledHighlights();
            const data = {
                videoSource: currentTab === 'file' ? 'local file' : document.getElementById('videoUrl').value,
                processedDate: new Date().toISOString(),
                totalHighlights: enabled.length,
                highlights: enabled.map((h, i) => ({
                    number: i + 1,
                    timestamp: h.timestamp,
                    formattedTime: formatTime(h.timestamp),
                    confidence: Math.round(h.confidence)
                }))
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `basketball-highlights-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function playPreviousClip() {
            const prev = findPrevEnabledIndex(currentHighlightIndex - 1);
            if (prev >= 0) {
                currentHighlightIndex = prev;
                playNextHighlight();
            }
        }

        function playNextClip() {
            let next = findNextEnabledIndex(currentHighlightIndex + 1);
            if (next < 0) {
                // Loop back to start
                next = findNextEnabledIndex(0);
            }
            if (next >= 0) {
                currentHighlightIndex = next;
                playNextHighlight();
            }
        }

        function playAllHighlights() {
            const enabled = getEnabledHighlights();
            if (enabled.length === 0) return;

            isPlayingAll = true;
            currentHighlightIndex = 0;

            // Skip to first enabled highlight
            while (currentHighlightIndex < highlights.length && highlights[currentHighlightIndex].enabled === false) {
                currentHighlightIndex++;
            }

            playNextHighlight();
        }

        function findNextEnabledIndex(fromIndex) {
            for (let i = fromIndex; i < highlights.length; i++) {
                if (highlights[i].enabled !== false) return i;
            }
            return -1;
        }

        function findPrevEnabledIndex(fromIndex) {
            for (let i = fromIndex; i >= 0; i--) {
                if (highlights[i].enabled !== false) return i;
            }
            return -1;
        }

        function playNextHighlight() {
            // Skip disabled highlights
            if (isPlayingAll && currentHighlightIndex < highlights.length && highlights[currentHighlightIndex].enabled === false) {
                currentHighlightIndex = findNextEnabledIndex(currentHighlightIndex);
            }

            if (!isPlayingAll || currentHighlightIndex < 0 || currentHighlightIndex >= highlights.length) {
                stopPlayingAll();
                return;
            }

            const highlight = highlights[currentHighlightIndex];
            const video = document.getElementById('videoPlayer');
            const enabledList = getEnabledHighlights();
            const enabledIdx = enabledList.indexOf(highlight);

            // Show overlay
            const overlay = document.getElementById('videoOverlay');
            overlay.style.display = 'block';
            document.getElementById('overlayClipNumber').textContent = enabledIdx + 1;
            document.getElementById('overlayTotalClips').textContent = enabledList.length;
            document.getElementById('overlayTimestamp').textContent = formatTime(highlight.timestamp);

            // Highlight the current item in the list
            document.querySelectorAll('.highlight-item').forEach((item, idx) => {
                item.classList.toggle('playing', idx === currentHighlightIndex);
            });

            // Scroll to current highlight in theater mode WITHOUT focus jump
            if (isTheaterMode) {
                const currentItem = document.querySelectorAll('.highlight-item')[currentHighlightIndex];
                if (currentItem) {
                    const container = document.getElementById('highlightsList');
                    const itemRect = currentItem.getBoundingClientRect();
                    const containerRect = container.getBoundingClientRect();

                    // Calculate scroll position to center the item
                    const scrollLeft = currentItem.offsetLeft - (containerRect.width / 2) + (itemRect.width / 2);
                    container.scrollLeft = scrollLeft;
                }
            }

            const startTime = Math.max(0, highlight.timestamp - 3);
            const endTime = highlight.timestamp + 1;
            const clipDuration = endTime - startTime;

            document.getElementById('overlayClipDuration').textContent = clipDuration.toFixed(1) + 's';

            video.currentTime = startTime;
            video.play();

            // Remove any existing listener
            if (playAllListener) {
                video.removeEventListener('timeupdate', playAllListener);
            }

            // Set up listener to move to next highlight and update progress
            playAllListener = () => {
                const elapsed = video.currentTime - startTime;
                const progress = Math.min(100, (elapsed / clipDuration) * 100);

                // Update overlay progress
                document.getElementById('overlayProgress').style.width = progress + '%';
                document.getElementById('overlayClipTime').textContent = elapsed.toFixed(1) + 's';

                if (video.currentTime >= endTime) {
                    video.removeEventListener('timeupdate', playAllListener);
                    // Find next enabled highlight
                    currentHighlightIndex = findNextEnabledIndex(currentHighlightIndex + 1);

                    // Small pause between highlights
                    setTimeout(() => {
                        if (isPlayingAll) {
                            playNextHighlight();
                        }
                    }, 300);
                }
            };

            video.addEventListener('timeupdate', playAllListener);
        }

        function stopPlayingAll() {
            isPlayingAll = false;
            const video = document.getElementById('videoPlayer');
            
            if (playAllListener) {
                video.removeEventListener('timeupdate', playAllListener);
                playAllListener = null;
            }
            
            video.pause();
            
            // Hide overlay
            document.getElementById('videoOverlay').style.display = 'none';
            
            // Remove playing class from all items
            document.querySelectorAll('.highlight-item').forEach(item => {
                item.classList.remove('playing');
            });
        }

        function enablePlaybackControls() {
            // No longer needed - removed mode buttons
        }

        function setupKeyboardNavigation() {
            document.addEventListener('keydown', (e) => {
                // Only handle if we have highlights and not typing in an input
                if (highlights.length === 0 || e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                    return;
                }
                
                const video = document.getElementById('videoPlayer');
                
                switch(e.key) {
                    case 'ArrowRight':
                        e.preventDefault();
                        playNextClip();
                        break;
                        
                    case 'ArrowLeft':
                        e.preventDefault();
                        playPreviousClip();
                        break;
                        
                    case ' ':
                        e.preventDefault();
                        if (video.paused) {
                            if (!isPlayingAll && highlights.length > 0) {
                                playAllHighlights();
                            } else {
                                video.play();
                            }
                        } else {
                            video.pause();
                        }
                        break;
                }
            });
        }

        function showStatus(message, type) {
            const statusEl = document.getElementById('statusMessage');
            statusEl.textContent = message;
            statusEl.className = 'status ' + (type || '');
            statusEl.style.display = 'flex';
        }

        // ‚îÄ‚îÄ‚îÄ FFmpeg WASM Integration ‚îÄ‚îÄ‚îÄ

        async function loadFFmpeg() {
            if (ffmpegLoaded) return true;
            if (ffmpegLoading) return false;
            ffmpegLoading = true;

            const overlay = document.getElementById('ffmpegLoading');
            const titleEl = document.getElementById('ffmpegLoadingTitle');
            const textEl = document.getElementById('ffmpegLoadingText');
            const progressEl = document.getElementById('ffmpegProgressFill');

            overlay.classList.add('active');
            titleEl.textContent = 'Loading Video Editor...';
            textEl.textContent = 'Downloading FFmpeg (~30 MB, first time only)';
            progressEl.style.width = '10%';

            try {
                // Dynamically load FFmpeg scripts from CDN
                await loadScript('https://unpkg.com/@ffmpeg/ffmpeg@0.12.15/dist/umd/ffmpeg.js')
                    .catch(() => loadScript('https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.15/dist/umd/ffmpeg.js'));
                progressEl.style.width = '20%';

                await loadScript('https://unpkg.com/@ffmpeg/util@0.12.2/dist/umd/util.js')
                    .catch(() => loadScript('https://cdn.jsdelivr.net/npm/@ffmpeg/util@0.12.2/dist/umd/util.js'));
                progressEl.style.width = '30%';

                textEl.textContent = 'Initializing FFmpeg core...';

                const { FFmpeg } = FFmpegWASM;
                const { toBlobURL } = FFmpegUtil;

                ffmpegInstance = new FFmpeg();

                ffmpegInstance.on('progress', ({ progress }) => {
                    const pct = Math.round(Math.max(0, Math.min(100, progress * 100)));
                    progressEl.style.width = pct + '%';
                    textEl.textContent = `Processing: ${pct}%`;
                });

                const coreURL = await toBlobURL(
                    'https://unpkg.com/@ffmpeg/core@0.12.10/dist/umd/ffmpeg-core.js',
                    'text/javascript'
                );
                progressEl.style.width = '50%';

                const wasmURL = await toBlobURL(
                    'https://unpkg.com/@ffmpeg/core@0.12.10/dist/umd/ffmpeg-core.wasm',
                    'application/wasm'
                );
                progressEl.style.width = '80%';

                await ffmpegInstance.load({ coreURL, wasmURL });
                progressEl.style.width = '100%';

                ffmpegLoaded = true;
                ffmpegLoading = false;
                overlay.classList.remove('active');
                return true;
            } catch (err) {
                console.error('FFmpeg load error:', err);
                ffmpegLoading = false;
                overlay.classList.remove('active');
                showStatus('Failed to load FFmpeg. Check your network connection and try again.', 'error');
                return false;
            }
        }

        function loadScript(src) {
            return new Promise((resolve, reject) => {
                // Skip if already loaded
                if (document.querySelector(`script[src="${src}"]`)) {
                    resolve();
                    return;
                }
                const s = document.createElement('script');
                s.src = src;
                s.onload = resolve;
                s.onerror = reject;
                document.head.appendChild(s);
            });
        }

        async function getVideoData() {
            if (videoDataForFFmpeg) return videoDataForFFmpeg;

            if (currentTab === 'file' && videoFile) {
                videoDataForFFmpeg = await videoFile.arrayBuffer();
                return videoDataForFFmpeg;
            } else {
                // For URL-based videos, try to fetch
                const video = document.getElementById('videoPlayer');
                try {
                    const response = await fetch(video.src);
                    videoDataForFFmpeg = await response.arrayBuffer();
                    return videoDataForFFmpeg;
                } catch (err) {
                    showStatus('Cannot access video data for clipping. Try uploading the video as a local file.', 'error');
                    return null;
                }
            }
        }

        function guessVideoExtension() {
            if (videoFile && videoFile.name) {
                const ext = videoFile.name.split('.').pop().toLowerCase();
                if (['mp4', 'webm', 'mkv', 'mov', 'avi'].includes(ext)) return ext;
            }
            return 'mp4';
        }

        async function extractClip(highlight) {
            const { fetchFile } = FFmpegUtil;
            const data = await getVideoData();
            if (!data) return null;

            const ext = guessVideoExtension();
            const inputName = `input.${ext}`;
            const outputName = `clip.${ext}`;

            const startTime = Math.max(0, highlight.timestamp - 3);
            const duration = 4; // 3 seconds before + 1 second after

            const overlay = document.getElementById('ffmpegLoading');
            const titleEl = document.getElementById('ffmpegLoadingTitle');
            const textEl = document.getElementById('ffmpegLoadingText');
            const progressEl = document.getElementById('ffmpegProgressFill');
            overlay.classList.add('active');
            titleEl.textContent = 'Extracting Clip...';
            textEl.textContent = 'Writing video data...';
            progressEl.style.width = '10%';

            try {
                await ffmpegInstance.writeFile(inputName, new Uint8Array(data));
                progressEl.style.width = '30%';
                textEl.textContent = 'Trimming clip...';

                await ffmpegInstance.exec([
                    '-ss', startTime.toFixed(2),
                    '-i', inputName,
                    '-t', duration.toFixed(2),
                    '-c', 'copy',
                    '-avoid_negative_ts', 'make_zero',
                    outputName
                ]);
                progressEl.style.width = '90%';

                const outputData = await ffmpegInstance.readFile(outputName);
                progressEl.style.width = '100%';

                // Cleanup
                await ffmpegInstance.deleteFile(inputName).catch(() => {});
                await ffmpegInstance.deleteFile(outputName).catch(() => {});

                overlay.classList.remove('active');

                const mimeType = ext === 'webm' ? 'video/webm' : 'video/mp4';
                return new Blob([outputData.buffer], { type: mimeType });
            } catch (err) {
                console.error('Clip extraction error:', err);
                overlay.classList.remove('active');
                showStatus('Failed to extract clip. The video format may not be supported.', 'error');
                return null;
            }
        }

        async function exportSingleClip(index) {
            const highlight = highlights[index];

            const loaded = await loadFFmpeg();
            if (!loaded) return;

            const blob = await extractClip(highlight);
            if (!blob) return;

            const ext = guessVideoExtension();
            const filename = `highlight-${index + 1}-${formatTime(highlight.timestamp).replace(':', 'm').replace('.', 's')}.${ext}`;

            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);

            showStatus(`Clip ${index + 1} exported!`, 'complete');
        }

        async function exportClip() {
            const enabled = getEnabledHighlights();
            if (enabled.length === 0) {
                showStatus('No enabled highlights to export.', 'error');
                return;
            }

            const loaded = await loadFFmpeg();
            if (!loaded) return;

            for (let i = 0; i < enabled.length; i++) {
                const h = enabled[i];
                const globalIdx = highlights.indexOf(h);

                const overlay = document.getElementById('ffmpegLoading');
                const titleEl = document.getElementById('ffmpegLoadingTitle');
                titleEl.textContent = `Exporting Clip ${i + 1} of ${enabled.length}...`;

                const blob = await extractClip(h);
                if (!blob) continue;

                const ext = guessVideoExtension();
                const filename = `highlight-${globalIdx + 1}-${formatTime(h.timestamp).replace(':', 'm').replace('.', 's')}.${ext}`;

                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);

                // Small delay between downloads
                if (i < enabled.length - 1) {
                    await new Promise(r => setTimeout(r, 500));
                }
            }

            showStatus(`${enabled.length} clip(s) exported!`, 'complete');
        }

        // ‚îÄ‚îÄ‚îÄ Native Share Sheet ‚îÄ‚îÄ‚îÄ

        async function shareSingleHighlight(index) {
            const highlight = highlights[index];
            const text = `Basketball Highlight #${index + 1} at ${formatTime(highlight.timestamp)} (Score: ${Math.round(highlight.confidence)})`;

            // Try sharing with video clip if FFmpeg is available
            if (navigator.canShare && videoFile) {
                try {
                    const loaded = await loadFFmpeg();
                    if (loaded) {
                        const blob = await extractClip(highlight);
                        if (blob) {
                            const ext = guessVideoExtension();
                            const file = new File([blob], `highlight-${index + 1}.${ext}`, { type: blob.type });
                            const shareData = { text, files: [file] };

                            if (navigator.canShare(shareData)) {
                                await navigator.share(shareData);
                                return;
                            }
                        }
                    }
                } catch (err) {
                    if (err.name === 'AbortError') return; // User cancelled
                    console.warn('File share failed, falling back to text share:', err);
                }
            }

            // Fallback: share text only
            try {
                await navigator.share({ text });
            } catch (err) {
                if (err.name !== 'AbortError') {
                    // Final fallback: copy to clipboard
                    navigator.clipboard.writeText(text).then(() => {
                        showStatus('Highlight info copied to clipboard!', 'complete');
                    });
                }
            }
        }

        async function shareHighlights() {
            const enabled = getEnabledHighlights();
            if (enabled.length === 0) {
                showStatus('No enabled highlights to share.', 'error');
                return;
            }

            const lines = enabled.map((h, i) =>
                `${i + 1}. ${formatTime(h.timestamp)} (Score: ${Math.round(h.confidence)})`
            );
            const text = `Basketball Highlights (${enabled.length} clips):\n${lines.join('\n')}`;

            try {
                await navigator.share({ text });
            } catch (err) {
                if (err.name !== 'AbortError') {
                    navigator.clipboard.writeText(text).then(() => {
                        showStatus('Highlights copied to clipboard!', 'complete');
                    });
                }
            }
        }
    </script>
</body>
</html>